#
# This file is a part of MolecularGraph.jl
# Licensed under the MIT License http://opensource.org/licenses/MIT
#

export
    QueryAny, QueryLiteral, QueryOperator, QueryTree, QueryTruthTable
    # removehydrogens, inferaromaticity,
    # query_relationship, filter_queries


struct QueryAny
    value::Bool
end


struct QueryLiteral
    operator::Symbol  # :eq, :gt?, :lt? ...
    key::Symbol
    value::Union{Symbol,Int,String,Bool,Nothing}
end
QueryLiteral(key) = QueryLiteral(:eq, key, true)
QueryLiteral(key, value) = QueryLiteral(:eq, key, value)

function Base.isless(q::QueryLiteral, r::QueryLiteral)
    q.key < r.key && return true
    q.key > r.key && return false
    q.operator < r.operator && return true
    q.operator > r.operator && return false
    return string(q.value) < string(r.value)
end
Base.:(==)(q::QueryLiteral, r::QueryLiteral; kwargs...
    ) = q.key == r.key && q.operator == r.operator && string(q.value) == string(r.value)


struct QueryOperator
    key::Symbol  # :and, :or, :not
    value::Vector{Union{QueryAny,QueryLiteral,QueryOperator}}
end

struct QueryTree
    tree::Union{QueryAny,QueryLiteral,QueryOperator}
end

Base.getindex(a::QueryTree, prop::Symbol) = getproperty(a, prop)


"""
    QueryTruthTable(fml::Function, props::Vector{QueryLiteral}) -> QueryTruthTable

Truth table evaluator for query match and containment. 

This is expected to be generated by using `generate_truthtable`. Note that the properties
must be unique and sorted if QueryTruthTable constructors is manually called for testing.

- function: function that takes a vector whose size is `length(props)`
  that corresponds to each property variables and returns true or false.
- props: QueryLiteral vector.
"""
struct QueryTruthTable
    func::Function
    props::Vector{QueryLiteral}
end

# Convenient constructors for testing
QueryTruthTable(fml::Function, props::Vector{T}
    ) where T <: Tuple = QueryTruthTable(fml, [QueryLiteral(p...) for p in props])

function QueryTruthTable(tree::Union{QueryAny,QueryLiteral,QueryOperator})
    tree isa QueryAny && return QueryTruthTable(x -> tree.value, [])
    props = sort(union(values(querypropmap(tree))...))
    qfunc = generate_queryfunc(tree, props)
    return QueryTruthTable(qfunc, props)
end


function querypropmap(tree)
    if tree isa QueryAny
        return Dict{Symbol,Vector{QueryLiteral}}()
    elseif tree.key in (:and, :or)
        m = Dict{Symbol,Set{QueryLiteral}}()
        for d in tree.value
            for (k, props) in querypropmap(d)
                !haskey(m, k) && (m[k] = Set{QueryLiteral}())
                push!(m[k], props...)
            end
        end
        return Dict(k => sort(collect(d)) for (k, d) in m)
    elseif tree.key === :not
        return querypropmap(tree.value[1])
    else  # tree isa QueryLiteral
        return Dict{Symbol,Vector{QueryLiteral}}(tree.key => [tree])
    end
end


function generate_queryfunc(tree, props)
    tree isa QueryAny && return arr -> tree.value
    if tree isa QueryLiteral
        idx = findfirst(x -> x == tree, props)
        return arr -> arr[idx]
    elseif tree.key === :not
        f = generate_queryfunc(tree.value[1], props)
        return arr -> ~f(arr)
    else
        fs = [generate_queryfunc(q, props) for q in tree.value]
        cond = Dict(:and => all, :or => any)
        return arr -> cond[tree.key](f(arr) for f in fs)
    end
end

function smiles_dict(tree)
    if tree isa QueryLiteral
        return Dict{Symbol,Any}(tree.key => tree.value)
    elseif tree.key === :not  # -> :not is only for aromatic in SMILES
        d = only(smiles_dict(tree.value[1]))
        return Dict{Symbol,Any}(d.first => ~d.second)
    else
        d = Dict{Symbol,Any}()
        for q in tree.value
            merge!(d, smiles_dict(q))
        end
        return d
    end
end

"""
    optimize_query(tree) -> Union{QueryAny,QueryLiteral,QueryOperator}

Return optimized query.

- absorption of QueryAny
  (ex. :and => (:any => true, A) -> A, :or => (:any => true, A) -> :any => true
- `:not` has the highest precedence in SMARTS, but only in the case like [!C],
  De Morgan's law will be applied to remove `:and` under `:not`.
  (ex. :not => (:and => (:atomsymbol => :C, :isaromatic => false)
   -> :or => (:not => (:atomsymbol => :C), isaromatic => true)
"""
function optimize_query(tree)
    tree isa QueryOperator || return tree
    if tree.key === :not
        cld = tree.value[1]
        if cld.key === :and  # only the cases like [!C]
            vals = Union{QueryAny,QueryLiteral,QueryOperator}[]
            for c in cld.value
                push!(vals, c.key === :not ? c.value[1] : QueryOperator(:not, [c]))
            end
            return QueryOperator(:or, vals)
        end
        return tree
    end
    clds = Union{QueryAny,QueryLiteral,QueryOperator}[]
    for cld in tree.value
        op = optimize_query(cld)
        op isa QueryAny && tree.key === :and && (cld.value ? continue : (return op))
        op isa QueryAny && tree.key === :or && (cld.value ? (return op) : continue)
        push!(clds, op)
    end
    isempty(clds) && return QueryAny(tree.key === :and)
    length(clds) == 1 && return clds[1]
    return QueryOperator(tree.key, clds)
end


"""
    removehydrogens(mol::QueryMol) -> QueryMol

Return the molecular query with hydrogen nodes removed.

function removehydrogens(qmol::QueryMol)
    # count H nodes and mark H nodes to remove
    hnodes = Set{Int}()
    hcntarr = zeros(Int, nodecount(qmol))
    for n in 1:nodecount(qmol)
        nq = nodeattr(qmol, n).query
        issubset(nq, QueryFormula(:symbol, :H), eval_recursive=false) || continue
        degree(qmol, n) == 1 || throw(ErrorException("Invalid hydrogen valence"))
        adj = iterate(adjacencies(qmol, n))[1]
        hcntarr[adj] += 1
        push!(hnodes, n)
    end
    qmol_ = deepcopy(qmol)
    heavynodes = setdiff(nodeset(qmol), hnodes)
    for n in heavynodes
        nq = nodeattr(qmol, n).query
        # no longer H nodes exist, so [!#1] would be ignored
        noth = QueryFormula(:not, QueryFormula(:symbol, :H))
        if nq == noth
            newq = QueryFormula(:any, true)
        elseif nq.key === :and && noth in nq.value
            if length(nq.value) == 2
                newq = collect(setdiff(nq.value, [noth]))[1]
            else
                newq = QueryFormula(:and, setdiff(nq.value, [noth]))
            end
        else
            newq = nq
        end
        # consider H nodes as a :total_hydrogens query
        adjhnfmls = collect(0:(hcntarr[n] - 1))
        if !isempty(adjhnfmls)
            nfmls = [QueryFormula(:not, QueryFormula(:total_hydrogens, i)) for i in adjhnfmls]
            newq = QueryFormula(:and, Set([newq, nfmls...]))
        end
        setnodeattr!(qmol_, n, SmartsAtom(tidyformula(newq)))
    end
    return querymol(nodesubgraph(qmol_, heavynodes))
end
"""

"""
    inferatomaromaticity(qmol::QueryMol)

Infer aromaticity of atoms and bonds, then return more specific query in the aspect of aromaticity.

function inferaromaticity(qmol::QueryMol)
    qmol_ = deepcopy(qmol)
    for n in 1:nodecount(qmol)
        nq = nodeattr(qmol, n).query
        issubset(nq, QueryFormula(:isaromatic, true), eval_recursive=false) && continue
        issubset(nq, QueryFormula(:isaromatic, false), eval_recursive=false) && continue
        # by topology query (!R, !r)
        if issubset(nq, QueryFormula(:ring_count, 0), eval_recursive=false)
            newq = QueryFormula(:and, Set([nq, QueryFormula(:isaromatic, false)]))
            setnodeattr!(qmol_, n, SmartsAtom(tidyformula(newq)))
            continue
        end
        # by atom symbol
        canbearom = [:B, :C, :N, :O, :P, :S, :As, :Se]
        notaromfml = QueryFormula(:and, Set([
            QueryFormula(:not, QueryFormula(:symbol, a)) for a in canbearom]))
        if issubset(nq, notaromfml, eval_recursive=false)
            newq = QueryFormula(:and, Set([nq, QueryFormula(:isaromatic, false)]))
            setnodeattr!(qmol_, n, SmartsAtom(tidyformula(newq)))
            continue
        end
        # by explicitly non-/aromatic incidences
        noincacc = QueryFormula(:and, Set([
            QueryFormula(:not, QueryFormula(:symbol, a)) for a in [:C, :N, :B]]))
        minacc = issubset(nq, noincacc, eval_recursive=false) ? 0 : 1
        nonaromcnt = 0
        # hydrogen query
        if issubset(nq, QueryFormula(:and, Set([
            QueryFormula(:not, QueryFormula(:total_hydrogens, 0)),
            QueryFormula(:not, QueryFormula(:total_hydrogens, 1))
        ])), eval_recursive=false)
            nonaromcnt += 2  # 2 is enough to be nonaromcnt > minacc
        elseif issubset(nq,
                QueryFormula(:not, QueryFormula(:total_hydrogens, 0)), eval_recursive=false)
            nonaromcnt += 1
        end
        # incidences
        hasarombond = false
        for inc in incidences(qmol, n)
            eq = edgeattr(qmol_, inc).query
            if issubset(eq, QueryFormula(:isaromatic, true), eval_recursive=false)
                hasarombond = true
                break
            end
            if issubset(eq, QueryFormula(:order, 2), eval_recursive=false)
                # C=O special case
                adjq = nodeattr(qmol, neighbors(qmol, n)[inc]).query
                if issubset(adjq, QueryFormula(:symbol, :O), eval_recursive=false)
                    continue
                end
            end
            if (issubset(eq, QueryFormula(:isaromatic, false), eval_recursive=false)
                    || issubset(eq, QueryFormula(:is_in_ring, false), eval_recursive=false))
                if issubset(eq, QueryFormula(:not, QueryFormula(:order, 1)), eval_recursive=false)
                    nonaromcnt += 2  # 2 is enough to be nonaromcnt > minacc
                else
                    nonaromcnt += 1
                end
            end
        end
        if hasarombond
            newq = QueryFormula(:and, Set([nq, QueryFormula(:isaromatic, true)]))
            setnodeattr!(qmol_, n, SmartsAtom(tidyformula(newq)))
        elseif nonaromcnt > minacc
            newq = QueryFormula(:and, Set([nq, QueryFormula(:isaromatic, false)]))
            setnodeattr!(qmol_, n, SmartsAtom(tidyformula(newq)))
        end
    end
    # by Huckel rule
    aromf = QueryFormula(:isaromatic, true)
    aors = QueryFormula(:or, Set([
        aromf,
        QueryFormula(:and, Set([
            QueryFormula(:order, 1),
            QueryFormula(:isaromatic, false)
        ]))
    ]))
    aord = QueryFormula(:or, Set([
        aromf,
        QueryFormula(:and, Set([
            QueryFormula(:order, 2),
            QueryFormula(:isaromatic, false)
        ]))
    ]))
    for ring in sssr(qmol)
        ringedges = edgeset(nodesubgraph(qmol, ring))
        pcnt = 0
        for n in ring
            nq = nodeattr(qmol, n).query
            if issubset(nq, QueryFormula(:isaromatic, true), eval_recursive=false)
                pcnt += 1
                continue
            end
            rincs = collect(intersect(incidences(qmol, n), ringedges))
            uq = edgeattr(qmol, rincs[1]).query
            vq = edgeattr(qmol, rincs[2]).query
            if uq == aors && vq == aord || vq == aors && uq == aord
                if issubset(nq, QueryFormula(:or,
                            Set([QueryFormula(:symbol, a) for a in [:B, :C, :N, :P, :As]])),
                        eval_recursive=false)
                    pcnt += 1
                    continue
                end
            elseif uq == aors && vq == aors
                if issubset(nq, QueryFormula(:or,
                            Set([QueryFormula(:symbol, a) for a in [:N, :O, :P, :S, :As, :Se]])),
                        eval_recursive=false)
                    pcnt += 2
                    continue
                elseif issubset(nq, QueryFormula(:symbol, :C), eval_recursive=false)
                    outer = collect(setdiff(incidences(qmol, n), ringedges))
                    if length(outer) == 1
                        outerq = edgeattr(qmol, outer[1]).query
                        oadjq = nodeattr(qmol, neighbors(qmol, n)[outer[1]]).query
                        if issubset(outerq, QueryFormula(:order, 2), eval_recursive=false) && issubset(oadjq, QueryFormula(:symbol, :O), eval_recursive=false)
                            continue
                        end
                    end
                end
            end
            pcnt = 0
            break
        end
        if pcnt % 4 == 2
            for n in ring
                nq = nodeattr(qmol, n).query
                newq = QueryFormula(:and, Set([nq, QueryFormula(:isaromatic, true)]))
                setnodeattr!(qmol_, n, SmartsAtom(tidyformula(newq)))
            end
            for e in ringedges
                setedgeattr!(qmol_, e, SmartsBond(aromf))
            end
        end
    end
    return qmol_
end




const DEFAULT_QUERY_RELATIONS = let
    qrfile = joinpath(dirname(@__FILE__), "../../assets/const/default_query_relations.yaml")
    include_dependency(qrfile)
    qrfile
end



struct DictDiGraph <: OrderedDiGraph
    # TODO: should be moved to Graph module
    # TODO: get rid of mutable Dict
    outneighbormap::Vector{Dict{Int,Int}}
    inneighbormap::Vector{Dict{Int,Int}}
    edges::Vector{Tuple{Int,Int}}
    nodeattrs::Vector{Dict}
    edgeattrs::Vector{Dict}
end
"""

"""
    dictdigraph(view::DiSubgraphView{DictDiGraph}) -> DictDiGraph

Generate a new `DictDiGraph` from a substructure view.

Graph property caches and attributes are not inherited.

function dictdigraph(view::DiSubgraphView{DictDiGraph})
    newg = DictDiGraph([], [], [], [], [])
    nkeys = sort(collect(nodeset(view)))
    ekeys = sort(collect(edgeset(view)))
    nmap = Dict{Int,Int}()
    for (i, n) in enumerate(nkeys)
        nmap[n] = i
        push!(newg.nodeattrs, nodeattr(view, n))
        push!(newg.outneighbormap, Dict())
        push!(newg.inneighbormap, Dict())
    end
    for (i, e) in enumerate(ekeys)
        (oldu, oldv) = getedge(view, e)
        u = nmap[oldu]
        v = nmap[oldv]
        push!(newg.edges, (u, v))
        push!(newg.edgeattrs, edgeattr(view, e))
        newg.outneighbormap[u][i] = v
        newg.inneighbormap[v][i] = u
    end
    return newg
end
"""

"""
    query_relationship(;sourcefile=DEFAULT_QUERY_RELATIONS) -> DictDiGraph

Generate query relationship diagram.

function query_relationship(;sourcefile=DEFAULT_QUERY_RELATIONS)
    graph = DictDiGraph([], [], [], [], [])
    keys = Dict()
    for (i, rcd) in enumerate(YAML.load(open(sourcefile)))
        rcd["parsed"] = smartstomol(rcd["query"])
        addnode!(graph, rcd)
        keys[rcd["key"]] = i
    end
    for rcd in nodeattrs(graph)
        if haskey(rcd, "isa")
            for e in rcd["isa"]
                addedge!(graph, keys[rcd["key"]], keys[e], Dict("relation" => "isa"))
            end
        end
        if haskey(rcd, "has")
            for e in rcd["has"]
                addedge!(graph, keys[rcd["key"]], keys[e], Dict("relation" => "has"))
            end
        end
    end
    return graph
end
"""

"""
    filter_queries(qr::DictDiGraph, mol::GraphMol) -> DictDiGraph

Filter query relationship diagram by the given molecule.
The filtered diagram represents query relationship that the molecule have.

function filter_queries(qr::DictDiGraph, mol::GraphMol; filtering=true)
    matched = Set{Int}()
    for n in reversetopologicalsort(qr)
        rcd = nodeattr(qr, n)
        if filtering
            if !issubset(successors(qr, n), matched)  # query containment filter
                continue
            end
        end
        # println("key: \$(rcd["key"])")
        # println("query: \$(rcd["query"])")
        # @time begin
            matches = collect(substructmatches(mol, rcd["parsed"]))
            if !isempty(matches)
                push!(matched, n)
                rcd["matched"] = Set([sort(collect(keys(m))) for m in matches])
            end
        # end
    end
    return dictdigraph(nodesubgraph(qr, matched))
end
"""
