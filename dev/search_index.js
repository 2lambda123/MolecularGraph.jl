var documenterSearchIndex = {"docs":
[{"location":"graph/traversal/#Graph-traversal-1","page":"Traversal","title":"Graph traversal","text":"","category":"section"},{"location":"graph/traversal/#Shortest-path-1","page":"Traversal","title":"Shortest path","text":"","category":"section"},{"location":"graph/traversal/#","page":"Traversal","title":"Traversal","text":"Modules = [Graph]\nPages   = [\"graph/shortestpath.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/traversal/#MolecularGraph.Graph.diameter-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Traversal","title":"MolecularGraph.Graph.diameter","text":"diameter(graph::AbstractGraph) -> Int\n\nCompute the diameter of the graph (the largest eccentricity of any nodes).\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.distance-Tuple{Function,Any,Any,Any}","page":"Traversal","title":"MolecularGraph.Graph.distance","text":"distance(graph::AbstractGraph, source::Int, target::Int) -> Int\nreversedistance(graph::DirectedGraph, source::Int, target::Int) -> Int\n\nCompute the distance (shortest path length) from source to target. If the nodes are not reachable each other, the value will be nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.distancematrix-Tuple{Function,Any}","page":"Traversal","title":"MolecularGraph.Graph.distancematrix","text":"distancematrix(graph::OrderedGraph) -> Matrix{Float64}\n\nGenerate the distance matrix of the graph.\n\nNote that the type of the generated matrix will be Float64. If the nodes are not reachable each other, the distance value will be Inf.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.eccentricity-Tuple{Function,Any,Any}","page":"Traversal","title":"MolecularGraph.Graph.eccentricity","text":"eccentricity(graph::UndirectedGraph, v::Int) -> Int\n\nCompute the eccentricity of the graph (the largest distance between v and any other nodes).\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.isreachable-Tuple{MolecularGraph.Graph.UndirectedGraph,Int64,Int64}","page":"Traversal","title":"MolecularGraph.Graph.isreachable","text":"reachablenodes(graph::AbstractGraph, u::Int, v::Int) -> Bool\nreversereachablenodes(graph::DirectedGraph, u::Int, v::Int) -> Bool\n\nReturn whether the node v is reachable from u.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.longestshortestpathnodes-Tuple{MolecularGraph.Graph.UndirectedGraph}","page":"Traversal","title":"MolecularGraph.Graph.longestshortestpathnodes","text":"longestshortestpathnodes(graph::UndirectedGraph) -> Vector{Int}\n\nCompute the longest shortest path in the graph (a path between two arbitrary peripheral nodes) as a vector of nodes that starts with one of the peripheral node and ends with the other side.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.reachablenodes-Tuple{MolecularGraph.Graph.UndirectedGraph,Int64}","page":"Traversal","title":"MolecularGraph.Graph.reachablenodes","text":"reachablenodes(graph::AbstractGraph, node::Int) -> Set{Int}\nreversereachablenodes(graph::DirectedGraph, node::Int) -> Set{Int}\n\nReturn the set of reachable nodes from node.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.shortestpathedges-Tuple{Function,Any,Any,Any}","page":"Traversal","title":"MolecularGraph.Graph.shortestpathedges","text":"shortestpathedges(graph::UndirectedGraph, u::Int, v::Int) -> Vector{Int}\n\nCompute the shortest path between u and v as a vector of the edges that forms the path. Return nothing if not reachable.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.shortestpathnodes-Tuple{Function,Any,Any,Any}","page":"Traversal","title":"MolecularGraph.Graph.shortestpathnodes","text":"shortestpathnodes(graph::UndirectedGraph, u::Int, v::Int) -> Vector{Int}\n\nCompute the shortest path between u and v as a vector of the nodes that forms the path. Return nothing if not reachable.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#Graph-isomorphism-1","page":"Isomorphism","title":"Graph isomorphism","text":"","category":"section"},{"location":"graph/isomorphism/#Subgraph-match-(VF2-algorithm)-1","page":"Isomorphism","title":"Subgraph match (VF2 algorithm)","text":"","category":"section"},{"location":"graph/isomorphism/#","page":"Isomorphism","title":"Isomorphism","text":"Modules = [Graph]\nPages   = [\"graph/isomorphism/vf2.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/isomorphism/#MolecularGraph.Graph.edgesubgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.edgesubgraphmatch","text":"edgesubgraphmatch(\n    G::AbstractGraph, H::AbstractGraph; kwargs...) -> Dict{Int,Int}\n\nReturn a edge induced subgraph isomorphism mapping between G and H. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.edgesubgraphmatches-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.edgesubgraphmatches","text":"edgesubgraphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Iterator\n\nGenerate edge induced subgraph isomorphism mappings between G and H.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.graphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.graphmatch","text":"graphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Dict{Int,Int}\n\nReturn an isomorphism mapping between G and H. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.graphmatches-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.graphmatches","text":"graphmatches(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Iterator\n\nGenerate isomorphism mappings between G and H. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.isedgesubgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.isedgesubgraphmatch","text":"isedgesubgraphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Bool\n\nReturn true if a node induced subgraph of G and H are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.isgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.isgraphmatch","text":"isgraphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Bool\n\nReturn true if G and H are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.issubgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.issubgraphmatch","text":"issubgraphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Bool\n\nReturn true if a node induced subgraph of G and H are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.subgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.subgraphmatch","text":"subgraphmatch(\n    G::AbstractGraph, H::AbstractGraph; kwargs...) -> Dict{Int,Int}\n\nReturn a subgraph isomorphism mapping between G and H. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.subgraphmatches-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.subgraphmatches","text":"subgraphmatches(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Iterator\n\nGenerate subgraph isomorphism mappings between G and H.\n\nKeyword arguments\n\nnodematcher(Function): node matcher function that takes two node indices as\n\narguments.\n\nedgematcher(Function): edge matcher function that takes two edge indices as\n\narguments.\n\nmandatory(Dict{Int,Int}): mandatory node matches (available for only VF2)\nforbidden(Dict{Int,Int}):   forbidden node matches (available for only VF2)\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#Maximum-common-subgraph-(Clique-detection-based-algorithm)-1","page":"Isomorphism","title":"Maximum common subgraph (Clique detection based algorithm)","text":"","category":"section"},{"location":"graph/isomorphism/#","page":"Isomorphism","title":"Isomorphism","text":"Modules = [Graph]\nPages   = [\"graph/isomorphism/cliquemcs.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/isomorphism/#MolecularGraph.Graph.findmces-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"Isomorphism","title":"MolecularGraph.Graph.findmces","text":"findmces(G::UndirectedGraph, H::UndirectedGraph; kwargs...\n    ) -> Tuple{Dict{Int,Int},Symbol}\n\nCompute maximum common edge induced subgraph between G and H.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.findmcis-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"Isomorphism","title":"MolecularGraph.Graph.findmcis","text":"findmcis(G::UndirectedGraph, H::UndirectedGraph; kwargs...\n    ) -> Tuple{Dict{Int,Int},Symbol}\n\nCompute maximum common induced subgraph between G and H.\n\nKeyword arguments:\n\nconnected(Bool): if true, apply connected MCS constraint.\ntopological(Bool): if true, apply topological constraint.\ndiameter(Int): distance cutoff for topological constraint.\ntolerance(Int): distance mismatch tolerance for topological constraint.\ntimeout(Int): abort calculation and return suboptimal results so far if the\n\nexecution time has reached the given value (default=60, in seconds).\n\ntargetsize(Int): abort calculation and return suboptimal result so far if the\n\ngiven mcs size achieved.\n\nnodematcher(Function): node matcher function that takes two node indices as\n\narguments.\n\nedgematcher(Function): edge matcher function that takes two edge indices as\n\narguments.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.mcessize-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.mcessize","text":"mcessize(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Int\n\nReturn the maximum common edge induced subgraph size (number of edges).\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.mcissize-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.mcissize","text":"mcissize(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Int\n\nReturn the maximum common induced subgraph size (number of nodes).\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#Graph-operations-1","page":"Operations","title":"Graph operations","text":"","category":"section"},{"location":"graph/operation/#Disjoint-union-1","page":"Operations","title":"Disjoint union","text":"","category":"section"},{"location":"graph/operation/#","page":"Operations","title":"Operations","text":"Modules = [Graph]\nPages   = [\"graph/disjointunion.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/operation/#MolecularGraph.Graph.disjointunion!-Union{Tuple{T}, Tuple{T,T,Vararg{T,N} where N}} where T<:MolecularGraph.Graph.OrderedGraph","page":"Operations","title":"MolecularGraph.Graph.disjointunion!","text":"disjointunion!(g1::T, g2::T, G::T...) where {T<:OrderedGraph} -> T\n\nGenerate disjoint union graph of given graphs. g1 will be overwritten by the union graph. Unlike non-destructive disjointunion, g1 does not retain any information about other given graphs but a bit faster.\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#MolecularGraph.Graph.disjointunion-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph,Vararg{MolecularGraph.Graph.UndirectedGraph,N} where N}","page":"Operations","title":"MolecularGraph.Graph.disjointunion","text":"disjointunion(g1::UndirectedGraph, g2::UndirectedGraph,\n    G::UndirectedGraph...) -> DisjointUnionGraph\n\nGenerate disjoint union graph of given graphs. The new graph with type DisjointUnionGraph retains mapping to the original graphs as nodes and edges attributes.\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#Line-graph-1","page":"Operations","title":"Line graph","text":"","category":"section"},{"location":"graph/operation/#","page":"Operations","title":"Operations","text":"Modules = [Graph]\nPages   = [\"graph/linegraph.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/operation/#MolecularGraph.Graph.linegraph-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Operations","title":"MolecularGraph.Graph.linegraph","text":"linegraph(G::AbstractGraph) -> LineGraph\n\nGenerate line graph.\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#Product-of-graphs-1","page":"Operations","title":"Product of graphs","text":"","category":"section"},{"location":"graph/operation/#","page":"Operations","title":"Operations","text":"Modules = [Graph]\nPages   = [\"graph/product.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/operation/#MolecularGraph.Graph.cartesianproduct-Tuple{MolecularGraph.Graph.OrderedGraph,MolecularGraph.Graph.OrderedGraph}","page":"Operations","title":"MolecularGraph.Graph.cartesianproduct","text":"cartesianproduct(G::OrderedGraph, H::OrderedGraph) -> CartesianProduct\n\nReturn the cartesian product of graphs G and H.\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#MolecularGraph.Graph.modularproduct-Tuple{MolecularGraph.Graph.OrderedGraph,MolecularGraph.Graph.OrderedGraph}","page":"Operations","title":"MolecularGraph.Graph.modularproduct","text":"modularproduct(G::OrderedGraph, H::OrderedGraph) -> ModularProduct\n\nReturn the modular product of graphs G and H.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#Graph-generator-1","page":"Generator","title":"Graph generator","text":"","category":"section"},{"location":"graph/generator/#","page":"Generator","title":"Generator","text":"Modules = [Graph]\nPages   = [\"graph/generator.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/generator/#MolecularGraph.Graph.circularladder-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.circularladder","text":"circularladder(n::Int; mutable=false) -> PlainGraph\n\nGenerate circular ladder graph CL_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.completebipartite-Tuple{Int64,Int64}","page":"Generator","title":"MolecularGraph.Graph.completebipartite","text":"completebipartite(m::Int,n::Int; mutable=false) -> PlainGraph\n\nGenerate bipartite graph K_mn.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.completegraph-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.completegraph","text":"completegraph(length::Int; mutable=false) -> PlainGraph\n\nGenerate complete graph K_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.cyclegraph-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.cyclegraph","text":"cyclegraph(length::Int; mutable=false) -> PlainGraph\n\nGenerate cycle graph C_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.generalizedpetersen-Tuple{Int64,Int64}","page":"Generator","title":"MolecularGraph.Graph.generalizedpetersen","text":"generalizedpetersen(n::Int, k::Int; mutable=false) -> PlainGraph\n\nGenerate generalized petersen graph G(nk).\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.laddergraph-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.laddergraph","text":"laddergraph(n::Int; mutable=false) -> PlainGraph\n\nGenerate ladder graph L_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.moebiusladder-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.moebiusladder","text":"moebiusladder(n::Int; mutable=false) -> PlainGraph\n\nGenerate Möbius ladder graph ML_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.pathgraph-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.pathgraph","text":"pathgraph(n::Int; mutable=false) -> PlainGraph\n\nGenerate path graph P_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.squaregrid-Tuple{Int64,Int64}","page":"Generator","title":"MolecularGraph.Graph.squaregrid","text":"squaregrid(m::Int,n::Int; mutable=false) -> PlainGraph\n\nGenerate m times n square grid graph.\n\nUse cartesianproduct for higher dimensional grid graphs.\n\n\n\n\n\n","category":"method"},{"location":"geometry/cartesian/#Cartesian-1","page":"Cartesian","title":"Cartesian","text":"","category":"section"},{"location":"geometry/cartesian/#","page":"Cartesian","title":"Cartesian","text":"Modules = [Geometry]\nPages   = [\"geometry/cartesian.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"geometry/cartesian/#MolecularGraph.Geometry.distance-Tuple{MolecularGraph.Geometry.Point,MolecularGraph.Geometry.Point}","page":"Cartesian","title":"MolecularGraph.Geometry.distance","text":"distance(u::Point, v::Point) -> Float64\ndistance(s::Segment) -> Float64\ndistance(coords::AbstractMatrix{T}) where {T<:Real} -> Float64\n\nReturn distance between two endpoints.\n\n\n\n\n\n","category":"method"},{"location":"geometry/cartesian/#MolecularGraph.Geometry.isclockwise-Tuple{AbstractArray{Float64,2}}","page":"Cartesian","title":"MolecularGraph.Geometry.isclockwise","text":"isclockwise(vertices::AbstractMatrix{Float64}) -> Union{Bool,Nothing}\n\nReturn true/false if given vertices of a polygon in 2D space are placed clockwise/anticlockwise. Return nothing if the polygon is self-intersecting or some vertices are overlapped.  \n\n\n\n\n\n","category":"method"},{"location":"geometry/cartesian/#MolecularGraph.Geometry.midpoint-Tuple{MolecularGraph.Geometry.Point,MolecularGraph.Geometry.Point}","page":"Cartesian","title":"MolecularGraph.Geometry.midpoint","text":"midpoint(u::Point, v::Point) -> Point\nmidpoint(s::Segment) -> Point\nmidpoint(coords::AbstractMatrix{T}) where {T<:Real} -> AbstractMatrix\n\nReturn the midpoint of u and v.\n\n\n\n\n\n","category":"method"},{"location":"geometry/cartesian/#MolecularGraph.Geometry.unitvector-Tuple{MolecularGraph.Geometry.Point,MolecularGraph.Geometry.Point}","page":"Cartesian","title":"MolecularGraph.Geometry.unitvector","text":"unitvector(u::Point, v::Point) -> Point\nunitvector(s::Segment) -> Point\nunitvector(coords::AbstractMatrix{T}) where {T<:Real} -> AbstractMatrix\n\nReturn u -> v vector of length 1.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#Interface-1","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"graph/interface/#","page":"Interface","title":"Interface","text":"Modules = [Graph]\nPages   = [\"graph/interface.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/interface/#MolecularGraph.Graph.addnode!-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.AbstractNode}","page":"Interface","title":"MolecularGraph.Graph.addnode!","text":"addnode!(graph) -> Int\naddnode!(graph, attr) -> Int\n\nAdd new node and return the node index. If the node attribute type is required, specify the node attribute object by node keyword.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.clearcache!-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Interface","title":"MolecularGraph.Graph.clearcache!","text":"clearcache!(graph::AbstractGraph) -> nothing\n\nClear calculated property caches.\n\nCalling clearcache! is recommended when the graph nodes/edges are added, removed or reindexed. You can Graph.clone the graph before destructive operation instead.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.clone","page":"Interface","title":"MolecularGraph.Graph.clone","text":"clone(graph::AbstractGraph) -> AbstractGraph\n\nReturn deep copy of the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/interface/#MolecularGraph.Graph.edgeattr-Tuple{MolecularGraph.Graph.AbstractGraph,Int64,Int64}","page":"Interface","title":"MolecularGraph.Graph.edgeattr","text":"edgeattr(graph::AbstractGraph, u::Int, v::Int\n    ) -> Union{AbstractEdge,Nothing}\n\nReturn the attribute object of an edge that connects u and v. If not found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgeattr-Tuple{MolecularGraph.Graph.AbstractGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.edgeattr","text":"edgeattr(graph::AbstractGraph, i::Int) -> AbstractEdge\n\nReturn the attribute object of edge i.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgeattrs-Tuple{Union{MolecularGraph.Graph.OrderedDiGraph, MolecularGraph.Graph.OrderedGraph, MolecularGraph.Graph.OrderedHyperGraph}}","page":"Interface","title":"MolecularGraph.Graph.edgeattrs","text":"edgeattrs(graph::Union{OrderedGraph,OrderedDiGraph}) -> Vector{AbstractEdge}\n\nReturn graph edge attributes.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgeattrtype-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Interface","title":"MolecularGraph.Graph.edgeattrtype","text":"edgeattrtype(graph) -> Type\n\nReturn edge attribute type.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgecount-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Interface","title":"MolecularGraph.Graph.edgecount","text":"edgecount(graph::AbstractGraph) -> Int\n\nReturn the number of graph edges.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgeset-Tuple{Union{MolecularGraph.Graph.OrderedDiGraph, MolecularGraph.Graph.OrderedGraph, MolecularGraph.Graph.OrderedHyperGraph}}","page":"Interface","title":"MolecularGraph.Graph.edgeset","text":"edgeset(graph::Union{OrderedGraph,OrderedDiGraph}) -> Set{Int}\n\nReturn the set of edge keys.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.getedge-Tuple{MolecularGraph.Graph.AbstractGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.getedge","text":"getedge(graph::AbstractGraph, i::Int) -> Tuple{Int,Int}\ngetedge(graph::HyperGraph, i::Int) -> Set{Int}\n\nReturn an edge.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.hasedge-Tuple{MolecularGraph.Graph.AbstractGraph,Int64,Int64}","page":"Interface","title":"MolecularGraph.Graph.hasedge","text":"hasedge(graph::UndirectedGraph, u::Int, v::Int) -> Bool\nhasedge(graph::DirectedGraph, source::Int, target::Int) -> Bool\n\nReturn whether the given two nodes are connected by at least one edge.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.indegree-Tuple{MolecularGraph.Graph.DirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.indegree","text":"indegree(graph::DirectedGraph, n::Int) -> Int\n\nReturn the number of inneighbors of the node 'n'.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.inneighbors-Tuple{MolecularGraph.Graph.DirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.inneighbors","text":"inneighbors(graph::DirectedGraph, i::Int) -> Dict{Int,Int}\n\nReturn the mapping of predecessor node keys and in edge keys connected to the given node.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.neighborcount-Tuple{MolecularGraph.Graph.AbstractGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.neighborcount","text":"neighborcount(graph::AbstractGraph, n::Int) -> Int\ndegree(graph::AbstractGraph, n::Int) -> Int\n\nReturn the number of adjacent nodes of the node 'n'.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.neighbors-Tuple{MolecularGraph.Graph.UndirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.neighbors","text":"neighbors(graph, i) -> Dict{Int,Int}\n\nReturn the mapping of incident edges and adjacent nodes of node i. If the graph is directed graph, both outneighbors and inneighbors are mapped.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodeattr-Tuple{MolecularGraph.Graph.AbstractGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.nodeattr","text":"nodeattr(graph::AbstractGraph, i::Int) -> AbstractNode\n\nReturn the attribute object of node i.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodeattrs-Tuple{Union{MolecularGraph.Graph.OrderedDiGraph, MolecularGraph.Graph.OrderedGraph, MolecularGraph.Graph.OrderedHyperGraph}}","page":"Interface","title":"MolecularGraph.Graph.nodeattrs","text":"nodeattrs(graph::Union{OrderedGraph,OrderedDiGraph}) -> Vector{AbstractNode}\n\nReturn graph node attributes.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodeattrtype-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Interface","title":"MolecularGraph.Graph.nodeattrtype","text":"nodeattrtype(graph) -> Type\n\nReturn node attribute type.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodecount-Tuple{MolecularGraph.Graph.UndirectedGraph}","page":"Interface","title":"MolecularGraph.Graph.nodecount","text":"nodecount(graph::AbstractGraph) -> Int\n\nReturn the number of graph nodes.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodeset-Tuple{Union{MolecularGraph.Graph.OrderedDiGraph, MolecularGraph.Graph.OrderedGraph, MolecularGraph.Graph.OrderedHyperGraph}}","page":"Interface","title":"MolecularGraph.Graph.nodeset","text":"nodeset(graph::Union{OrderedGraph,OrderedDiGraph}) -> Set{Int}\n\nReturn the set of node keys.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.outdegree-Tuple{MolecularGraph.Graph.DirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.outdegree","text":"outdegree(graph::DirectedGraph, n::Int) -> Int\n\nReturn the number of outneighbors of the node 'n'.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.outneighbors-Tuple{MolecularGraph.Graph.DirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.outneighbors","text":"outneighbors(graph::DirectedGraph, i::Int) -> Dict{Int,Int}\n\nReturn the mapping of successor node keys and out edge keys connected to the given node.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.setedgeattr!-Tuple{MolecularGraph.Graph.AbstractGraph,Int64,MolecularGraph.Graph.AbstractEdge}","page":"Interface","title":"MolecularGraph.Graph.setedgeattr!","text":"setedgeattr!(graph::AbstractGraph, i::Int, attr::AbstractNode)\n\nUpdate the edge attribute.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.setnodeattr!-Tuple{MolecularGraph.Graph.AbstractGraph,Int64,MolecularGraph.Graph.AbstractNode}","page":"Interface","title":"MolecularGraph.Graph.setnodeattr!","text":"setnodeattr!(graph::AbstractGraph, i::Int, attr::AbstractNode)\n\nUpdate the node attribute.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.unlinkedges","page":"Interface","title":"MolecularGraph.Graph.unlinkedges","text":"unlinkedges(graph, edges)\n\nDelete given edges from the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/interface/#MolecularGraph.Graph.unlinknodes","page":"Interface","title":"MolecularGraph.Graph.unlinknodes","text":"unlinknodes(graph, nodes)\n\nDelete given nodes and its incident edges from the graph.\n\n\n\n\n\n","category":"function"},{"location":"moleculargraph/mcs/#Structure-match-1","page":"MCS","title":"Structure match","text":"","category":"section"},{"location":"moleculargraph/mcs/#","page":"MCS","title":"MCS","text":"Modules = [MolecularGraph]\nPages   = [\"mcs.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/mcs/#MolecularGraph.mcesmol-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"MCS","title":"MolecularGraph.mcesmol","text":"mcesmol(mol1::UndirectedGraph, mol2::UndirectedGraph; kwargs...\n    ) -> Tuple{Dict{Int,Int},Symbol}\n\nCompute maximum common edge induced substructure (MCES) of mol1 and mol2.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mcs/#MolecularGraph.mcismol-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"MCS","title":"MolecularGraph.mcismol","text":"mcismol(mol1::UndirectedGraph, mol2::UndirectedGraph; kwargs...\n    ) -> Tuple{Dict{Int,Int},Symbol}\n\nCompute maximum common induced substructure (MCIS) of mol1 and mol2.\n\nKeyword arguments\n\nconnected(Bool): if true, apply connected MCS constraint.\ntopological(Bool): if true, apply topological constraint.\ndiameter(Int): distance cutoff for topological constraint.\ntolerance(Int): distance mismatch tolerance for topological constraint.\ntimeout(Int): abort calculation and return suboptimal results if the execution\n\ntime has reached the given value (default=60, in seconds).\n\ntargetsize(Int): abort calculation and return suboptimal result so far if the\n\ngiven mcs size achieved.\n\nReferences\n\nKawabata, T. (2011). Build-Up Algorithm for Atomic Correspondence between\n\nChemical Structures. Journal of Chemical Information and Modeling, 51(8), 1775–1787. https://doi.org/10.1021/ci2001023\n\nhttps://www.jstage.jst.go.jp/article/ciqs/2017/0/2017P4/article/-char/en\n\n\n\n\n\n","category":"method"},{"location":"graph/topology/#Graph-topology-1","page":"Topology","title":"Graph topology","text":"","category":"section"},{"location":"graph/topology/#Cycle-1","page":"Topology","title":"Cycle","text":"","category":"section"},{"location":"graph/topology/#","page":"Topology","title":"Topology","text":"Modules = [Graph]\nPages   = [\"graph/cycle.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/topology/#Connectivity-1","page":"Topology","title":"Connectivity","text":"","category":"section"},{"location":"graph/topology/#","page":"Topology","title":"Topology","text":"Modules = [Graph]\nPages   = [\"graph/connectivity.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/topology/#Planarity-1","page":"Topology","title":"Planarity","text":"","category":"section"},{"location":"graph/topology/#","page":"Topology","title":"Topology","text":"Modules = [Graph]\nPages   = [\"graph/planarity.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/io/#Molecule-I/O-1","page":"I/O","title":"Molecule I/O","text":"","category":"section"},{"location":"moleculargraph/io/#SDFile-reader-1","page":"I/O","title":"SDFile reader","text":"","category":"section"},{"location":"moleculargraph/io/#","page":"I/O","title":"I/O","text":"Modules = [MolecularGraph]\nPages   = [\"sdfilereader.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/io/#MolecularGraph.sdfilereader-Tuple{IO}","page":"I/O","title":"MolecularGraph.sdfilereader","text":"sdfilereader(file::IO)\nsdfilereader(path::AbstractString)\n\nRead SDFile data from input stream (or a file path as a string) and return a lazy iterator that yields molecule objects.\n\nsdfilereader does not stop and raise errors when an erroneous or incompatible SDFile block is read but produces an error message and yields an empty molecule. If this behavior is not desirable, you can use the customized supplier function instead of default supplier nohaltsupplier\n\nfunction customsupplier()\n    mol = try\n        parse(SDFile, block)\n    catch e\n        throw(ErrorException(\"incompatible molecule found, aborting...\"))\n    end\nend\n\nfunction sdfilereader(file::IO)\n    return SDFileReader(eachline(file), customsupplier)\nend\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/io/#MolecularGraph.sdftomol-Tuple{Any}","page":"I/O","title":"MolecularGraph.sdftomol","text":"sdftomol(lines) -> GraphMol{SDFileAtom,SDFileBond}\nsdftomol(file::IO) -> GraphMol{SDFileAtom,SDFileBond}\nsdftomol(path::AbstractString) -> GraphMol{SDFileAtom,SDFileBond}\n\nRead a SDFile(.sdf or .mol) and parse it into a molecule object. The given argument should be a file input stream, a file path as a string or an iterator that yields each sdfile text lines.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/io/#SDFile-writer-1","page":"I/O","title":"SDFile writer","text":"","category":"section"},{"location":"moleculargraph/io/#","page":"I/O","title":"I/O","text":"Modules = [MolecularGraph]\nPages   = [\"sdfilewriter.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/io/#MolecularGraph.sdfilewriter-Tuple{IO,Any}","page":"I/O","title":"MolecularGraph.sdfilewriter","text":"sdfilewriter(io::IO, mols)\nsdfilewriter(filename::AbstractString, mols)\n\nWrite molecule data to the output stream as a SDFile format file.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/io/#SMILES/SMARTS-1","page":"I/O","title":"SMILES/SMARTS","text":"","category":"section"},{"location":"moleculargraph/io/#","page":"I/O","title":"I/O","text":"Modules = [MolecularGraph]\nPages   = [\"smarts/base.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/io/#MolecularGraph.smartstomol-Tuple{AbstractString}","page":"I/O","title":"MolecularGraph.smartstomol","text":"smartstomol(smarts::AbstractString) -> QueryMol{SmartsAtom,SmartsBond}\n\nParse SMARTS string into QueryMol object.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/io/#MolecularGraph.smilestomol-Tuple{AbstractString}","page":"I/O","title":"MolecularGraph.smilestomol","text":"smilestomol(smiles::AbstractString) -> GraphMol{SmilesAtom,SmilesBond}\n\nParse SMILES string into GraphMol object.\n\n\n\n\n\n","category":"method"},{"location":"design/#Design-of-molecular-graph-models-1","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"","category":"section"},{"location":"design/#Graph-type-hierarchy-1","page":"Design of molecular graph models","title":"Graph type hierarchy","text":"","category":"section"},{"location":"design/#","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"(AbstractGraph)\n(UndirectedGraph)\n(OrderedGraph)\nPlainGraph\nImmutablePlainGraph\nGraphMol{Atom,Bond}\nSDFile (Alias of GraphMol{SDFileAtom,SDFileBond})\nSMILES (Alias of GraphMol{SmilesAtom,SmilesBond})\nQueryMol{QueryAtom,QueryBond}\nSMARTS (Alias of QueryMol{SmartsAtom,SmartsBond})\nLineGraph\nCartesianProductGraph\nModularProductGraph\nSubgraphView{UndirectedGraph}\n(DirectedGraph)\n(OrderedDiGraph)\nPlainDiGraph\nFunctionalGroupClassGraph\nDiSubgraphView{DirectedGraph}\nHyperGraph?","category":"page"},{"location":"design/#AbstractGraph-methods-1","page":"Design of molecular graph models","title":"AbstractGraph methods","text":"","category":"section"},{"location":"design/#","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"getnode, getedge, hasedge\nneighbors and its derivatives\nnodecount\nedgecount\nnodeset\nedgeset","category":"page"},{"location":"design/#DirectedGraph-methods-1","page":"Design of molecular graph models","title":"DirectedGraph methods","text":"","category":"section"},{"location":"design/#","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"outneighbors and inneighbors","category":"page"},{"location":"design/#OrderedGraph-methods-1","page":"Design of molecular graph models","title":"OrderedGraph methods","text":"","category":"section"},{"location":"design/#","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"nodesiter\nedgesiter\nnodeattrs\nedgeattrs","category":"page"},{"location":"design/#OrderedGraph-1","page":"Design of molecular graph models","title":"OrderedGraph","text":"","category":"section"},{"location":"design/#","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"OrderedGraph consists of vectors of neighborhood map (incident edge => adjacent node) and edge (tuple of node index pair) vector.","category":"page"},{"location":"design/#QueryMol-1","page":"Design of molecular graph models","title":"QueryMol","text":"","category":"section"},{"location":"design/#","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"QueryMol consists of QueryAtom and QueryBond that represent molecular query (ex. atom symbol is 'O' and charge is -1, bond order is 1 and not in rings, ...). This type of objects typically built from SMARTS query.","category":"page"},{"location":"design/#Node-type-hierarchy-1","page":"Design of molecular graph models","title":"Node type hierarchy","text":"","category":"section"},{"location":"design/#","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"(AbstractNode)\n(Atom)\nSDFileAtom\nSmilesAtom\n(QueryAtom)\nSmartsAtom","category":"page"},{"location":"design/#Edge-type-hierarchy-1","page":"Design of molecular graph models","title":"Edge type hierarchy","text":"","category":"section"},{"location":"design/#","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"(AbstractEdge)\n(UndirectedEdge)\nEdge\n(Bond)\nSDFileBond\nSmilesBond\n(QueryBond)\nSmartsBond\n(DirectedEdge)\nArrow","category":"page"},{"location":"moleculargraph/properties/#Molecular-properties-1","page":"Chemical properties","title":"Molecular properties","text":"","category":"section"},{"location":"moleculargraph/properties/#","page":"Chemical properties","title":"Chemical properties","text":"Modules = [MolecularGraph]\nPages   = [\"properties.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/properties/#MolecularGraph.hacceptorcount-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.hacceptorcount","text":"hacceptorcount(mol::GraphMol) -> Int\n\nReturn the number of hydrogen bond acceptors (N, O and F).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.hdonorcount-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.hdonorcount","text":"hdonorcount(mol::GraphMol) -> Int\n\nReturn the number of hydrogen bond donors (O and N attached to hydrogens).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.molweight-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.molweight","text":"molweight(mol::GraphMol; digits=2) -> Float64\n\nReturn standard molecular weight.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.rotatablecount-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.rotatablecount","text":"rotatablecount(mol::GraphMol) -> Int\n\nReturn the number of rotatable bonds.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.wclogp-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.wclogp","text":"wclogp(mol::GraphMol) -> Float64\n\nReturn predicted logP value calculated by using Wildman and Crippen method.\n\nReference\n\nWildman, S. A. and Crippen, G. M. (1999). Prediction of Physicochemical Parameters by Atomic Contributions. Journal of Chemical Information and Modeling, 39(5), 868–873. https://doi.org/10.1021/ci990307l\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#Preprocessing-1","page":"Preprocessing","title":"Preprocessing","text":"","category":"section"},{"location":"moleculargraph/preprocess/#","page":"Preprocessing","title":"Preprocessing","text":"Modules = [MolecularGraph]\nPages   = [\"preprocess.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/preprocess/#MolecularGraph.addhydrogens!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.addhydrogens!","text":"addhydrogens!(mol::GraphMol) -> GraphMol\n\nAdd hydrogen nodes to the molecular graph explicitly.\n\nNote that this function edits Atom and Bond object fields directly (see Graph.clone and Graph.clearcache!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.allhydrogens-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.allhydrogens","text":"allhydrogens(mol::GraphMol) -> Set{Int}\n\nReturn a set of hydrogen nodes.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.depolarize!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.depolarize!","text":"depolarize!(mol::GraphMol)\n\nDepolarize oxo groups except in the case that polarization is required for aromaticity.\n\nNote that this function edits Atom and Bond object fields directly (see Graph.clone and Graph.clearcache!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.largestcomponentgraph-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.largestcomponentgraph","text":"largestcomponentgraph(mol::GraphMol) -> SubgraphView\n\nReturn largest connected component view of the molecular graph.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.largestcomponentnodes-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.largestcomponentnodes","text":"largestcomponentnodes(mol::GraphMol) -> Set{Int}\n\nReturn a set of nodes in the largest connected component.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.neutralizeacids!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.neutralizeacids!","text":"neutralizeacids!(mol::GraphMol)\n\nNeutralize oxo(thio) acids.\n\nNote that this function edits Atom object fields directly (see Graph.clone and Graph.clearcache!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.neutralizeoniums!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.neutralizeoniums!","text":"neutralizeoniums!(mol::GraphMol)\n\nNeutralize 1-3° oniums. Permanently charged quart-oniums will not be neutralized.\n\nNote that this function edits Atom object fields directly (see Graph.clone and Graph.clearcache!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.preprocess!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.preprocess!","text":"preprocess!(mol::GraphMol)\n\nDefault molecular preprocessing method.\n\nIonized acids and oniums will be neutralized (neutralizeacids! and neutralizeoniums!).\nIf there is several possible resonance structures, the one which have less total charge (if they are even, the one which have less maximum bond order) will be selected (depolarize! and toallenelike!).\n\nFor further preprocessing, following removehydrogens, removestereohydrogens and largestcomponentgraph would work well.\n\nNote that this function edits Atom and Bond object fields directly (see Graph.clone and Graph.clearcache!).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.removehydrogens-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.removehydrogens","text":"removehydrogens(mol::GraphMol) -> GraphMol\n\nReturn molecule whose hydrogen nodes are removed.\n\nIf option all is set to false, only trivial hydrogens are removed (see trivialhydrogens). If you want to keep stereochemistry, remove hydrogens with all=false, and do removestereohydrogens.\n\nIf \n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.toallenelike!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.toallenelike!","text":"toallenelike!(mol::GraphMol)\n\nConvert triple bonds with charges into allene-like structure (ex. [C-][N+]#N -> C=[N+]=[N-]).\n\nNote that this function edits Atom and Bond object fields directly (see Graph.clone and Graph.clearcache!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.trivialhydrogens-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.trivialhydrogens","text":"trivialhydrogens(mol::GraphMol) -> Set{Int}\n\nReturn a set of trivial hydrogen nodes (light hydrogens which are uncharged, non-radical, non-stereospecific and attached to organic heavy atoms)\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#Stereochemistry-1","page":"Preprocessing","title":"Stereochemistry","text":"","category":"section"},{"location":"moleculargraph/preprocess/#","page":"Preprocessing","title":"Preprocessing","text":"Modules = [MolecularGraph]\nPages   = [\"stereo.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/preprocess/#MolecularGraph.addstereohydrogens-Tuple{GraphMol{SmilesAtom,SmilesBond}}","page":"Preprocessing","title":"MolecularGraph.addstereohydrogens","text":"addstereohydrogens(mol::SMILES) -> SMILES\n\nReturn new molecule with explicit hydrogen nodes attached to stereocenters.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.optimizewedges!-Tuple{GraphMol{SDFileAtom,SDFileBond}}","page":"Preprocessing","title":"MolecularGraph.optimizewedges!","text":"optimizewedges!(mol::SDFile)\n\nOptimize dashes and wedges representations. Typical stereocenters can be drawn as four bonds including only a wedge and/or a dash, so if there are too many dashes and wedges, some of them will be converted to normal single bond without changing any stereochemistry.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.removestereohydrogens-Tuple{GraphMol{SmilesAtom,SmilesBond}}","page":"Preprocessing","title":"MolecularGraph.removestereohydrogens","text":"removestereohydrogens(mol::SMILES) -> SMILES\n\nReturn new molecule without explicit hydrogen nodes attached to the stereocenters.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.setdiastereo!-Tuple{GraphMol{SmilesAtom,SmilesBond}}","page":"Preprocessing","title":"MolecularGraph.setdiastereo!","text":"setdiastereo!(mol::Union{SMILES,SDFile}) -> nothing\n\nSet diastereomerism flags to Bond.stereo fields of double bonds.\n\n:unspecified, :cis or :trans will be assigned according to configurations of bonds labeled by lower indices. (ex. SMILES C/C=C(C)/C have 4 explicit bonds 1:C/C, 2:C=C, 3:C(C) and 4:C/C. 1st bond is prior to the other implicit hydrogen attached to 2nd atom, and 3rd bond is prior to 4th bond in index label order. 1st and 3th atom are in cis position, so Bond.stereo of 2nd bond will be set to :cis.)\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.setstereocenter!-Tuple{GraphMol{SDFileAtom,SDFileBond}}","page":"Preprocessing","title":"MolecularGraph.setstereocenter!","text":"setstereocenter!(mol::SDFile)\n\nSet stereocenter information to Atom.stereo (:unspecified, :clockwise, :anticlockwise or :atypical). Clockwise/anticlockwise means the configuration of 2-4th nodes in index label order when we see the chiral center from the node labeled by the lowest index. If there is an implicit hydrogen, its index label will be regarded as the same as the stereocenter atom.\n\nNote that setstereocenter! will optimize dashes and wedges by using optimizewedges! inside it. If you do not want to change the bond notation, clone the molecule before running setstereocenter!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/funcgroup/#Functional-group-detection-1","page":"Functional group detection","title":"Functional group detection","text":"","category":"section"},{"location":"moleculargraph/funcgroup/#","page":"Functional group detection","title":"Functional group detection","text":"Modules = [MolecularGraph]\nPages   = [\"funcgroup.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/funcgroup/#MolecularGraph.functionalgroupgraph-Tuple{GraphMol}","page":"Functional group detection","title":"MolecularGraph.functionalgroupgraph","text":"functionalgroupgraph(mol::GraphMol) -> FunctionalGroupClassifier\n\nGenerate functional group graph that is a directed acyclic graph similar to an ontology graph.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#Structure-match-1","page":"Substructure match","title":"Structure match","text":"","category":"section"},{"location":"moleculargraph/substructure/#","page":"Substructure match","title":"Substructure match","text":"Modules = [MolecularGraph]\nPages   = [\"substructure.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/substructure/#MolecularGraph.fastquerymatches-Tuple{MolecularGraph.Graph.UndirectedGraph,QueryMol}","page":"Substructure match","title":"MolecularGraph.fastquerymatches","text":"fastquerymatches(mol::UndirectedGraph, query::QueryMol; kwargs...\n    ) -> Dict{Int,Int}\n\nGenerate query match mappings between mol and query. If no match found, return nothing.\n\nThe query should not have any component level expression that means it should not have any dots (.). This is intended for use in functional group detection.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#MolecularGraph.isquerymatch-Tuple{Any,Any}","page":"Substructure match","title":"MolecularGraph.isquerymatch","text":"isquerymatch(mol, query; kwargs...)\n\nReturn whether mol matches with the query.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#MolecularGraph.querymatch-Tuple{MolecularGraph.Graph.UndirectedGraph,QueryMol}","page":"Substructure match","title":"MolecularGraph.querymatch","text":"querymatch(mol::UndirectedGraph, query::QueryMol; kwargs...) -> Dict{Int,Int}\n\nGenerate substructure match mappings between mol1 and mol2. If no match found, return nothing.\n\nThis accepts also disconnected single atom but returns only the first match. This function is intended for use in SMARTS query search\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#MolecularGraph.structmatches-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"Substructure match","title":"MolecularGraph.structmatches","text":"structmatches(mol1::UndirectedGraph, mol2::UndirectedGraph; kwargs...) -> Iterator\n\nGenerate molecular graph match mappings between mol1 and mol2. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#MolecularGraph.substructmatches-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"Substructure match","title":"MolecularGraph.substructmatches","text":"substructmatches(mol1::UndirectedGraph, mol2::UndirectedGraph; kwargs...) -> Iterator\n\nGenerate substructure match mappings between mol1 and mol2. If no match found, return nothing.\n\nThe mapping is based on only edge induced subgraph isomorphism and therefore it does not care disconnected single atom matches. This function is intended for use in substructure search. If you need single atom SMARTS match (ex. [#16;X2;!R]), see querymatch.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#Molecular-structure-drawing-1","page":"Structure drawing","title":"Molecular structure drawing","text":"","category":"section"},{"location":"moleculargraph/draw/#","page":"Structure drawing","title":"Structure drawing","text":"Modules = [MolecularGraph]\nPages   = [\"./draw/base.jl\", \"./draw/draw2d.jl\", \"./draw/svg.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/draw/#MolecularGraph.DRAW_SETTING","page":"Structure drawing","title":"MolecularGraph.DRAW_SETTING","text":"DRAW_SETTING\n\nDefault setting parameters of the molecule drawing canvas.\n\nRequired fields\n\n:display_terminal_carbon(Bool) whether to display terminal C atom or not\n:double_bond_notation(Symbol)\n:alongside: all double bonds are represented as a carbon skeleton and               a segment alongside it.\n:dual: all double bonds are represented as two equal length parallel          segments.\n:chain: :dual for chain bonds and :alongside for ring bonds\n:terminal: :dual for terminal bonds (adjacent to degree=1 node) and              :alongside for others (default)\n:atomcolor(Dict{Symbol,Color}) atom symbol and bond colors for organic atoms\n:defaul_atom_color(Dict{Symbol,Color}) colors for other atoms\n\n\n\n\n\n","category":"constant"},{"location":"moleculargraph/draw/#MolecularGraph.atomcolor-Tuple{GraphMol}","page":"Structure drawing","title":"MolecularGraph.atomcolor","text":"atomcolor(mol::GraphMol; setting=DRAW_SETTING) -> Vector{Color}\n\nReturn atom colors for molecule 2D drawing\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#MolecularGraph.chargesign-Tuple{Int64}","page":"Structure drawing","title":"MolecularGraph.chargesign","text":"chargesign(charge::Int) -> String\n\nGet a charge sign.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#MolecularGraph.draw2d!-Tuple{Canvas,MolecularGraph.Graph.UndirectedGraph}","page":"Structure drawing","title":"MolecularGraph.draw2d!","text":"draw2d!(canvas::Canvas, mol::UndirectedGraph;\n        setting=copy(DRAW_SETTING), recalculate=false)\n\nDraw molecular image to the canvas.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#MolecularGraph.isatomvisible-Tuple{GraphMol}","page":"Structure drawing","title":"MolecularGraph.isatomvisible","text":"isatomvisible(mol::GraphMol; setting=DRAW_SETTING) -> Vector{Bool}\n\nReturn whether the atom is visible in the 2D drawing.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#MolecularGraph.drawsvg-Tuple{MolecularGraph.Graph.UndirectedGraph,Int64,Int64}","page":"Structure drawing","title":"MolecularGraph.drawsvg","text":"drawsvg(mol::GraphMol, width::Int, height::Int)\n\nGenerate molecular structure image as a SVG format string.\n\nwidth and height specifies the size of the image (width and height attribute of svg tag).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#MolecularGraph.initcanvas!-Tuple{Canvas,GraphMol}","page":"Structure drawing","title":"MolecularGraph.initcanvas!","text":"initcanvas!(canvas::Canvas, mol::GraphMol)\n\nMove and adjust the size of the molecule for drawing.\n\n\n\n\n\n","category":"method"},{"location":"graph/clique/#Maximum-clique-1","page":"Clique","title":"Maximum clique","text":"","category":"section"},{"location":"graph/clique/#","page":"Clique","title":"Clique","text":"Modules = [Graph]\nPages   = [\"graph/clique.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/clique/#MolecularGraph.Graph.maximalcliques-Union{Tuple{T}, Tuple{T}} where T<:MolecularGraph.Graph.UndirectedGraph","page":"Clique","title":"MolecularGraph.Graph.maximalcliques","text":"maximalcliques(graph::UndirectedGraph; kwargs...\n    ) -> Tuple{Vector{Set{Int}}, Symbol}\n\nReturn maximal cliques.\n\nReference\n\nTomita, E., Tanaka, A., & Takahashi, H. (2006). The worst-case time complexity for generating all maximal cliques and computational experiments. Theoretical Computer Science, 363(1), 28–42. https://doi.org/10.1016/J.TCS.2006.06.015\nCazals, F., & Karande, C. (2008). A note on the problem of reporting maximal cliques. Theoretical Computer Science, 407(1–3), 564–568. https://doi.org/10.1016/j.tcs.2008.05.010\n\n\n\n\n\n","category":"method"},{"location":"graph/clique/#MolecularGraph.Graph.maximalconncliques-Union{Tuple{T}, Tuple{T}} where T<:MolecularGraph.Graph.UndirectedGraph","page":"Clique","title":"MolecularGraph.Graph.maximalconncliques","text":"maximalconncliques(graph::ModularProduct; kwargs...\n    ) -> Tuple{Vector{Set{Int}}, Symbol}\n\nReturn maximal connected cliques.\n\nReference\n\nCazals, F., & Karande, C. (2005). An algorithm for reporting maximal c-cliques. Theoretical Computer Science, 349(3), 484–490. https://doi.org/10.1016/j.tcs.2005.09.038\n\n\n\n\n\n","category":"method"},{"location":"graph/clique/#MolecularGraph.Graph.maximumclique-Union{Tuple{T}, Tuple{T}} where T<:MolecularGraph.Graph.UndirectedGraph","page":"Clique","title":"MolecularGraph.Graph.maximumclique","text":"maximumclique(graph::UndirectedGraph; kwargs...) -> Tuple{Set{Int}, Symbol}\n\nReturn a maximum clique.\n\n\n\n\n\n","category":"method"},{"location":"graph/clique/#MolecularGraph.Graph.maximumconnclique-Union{Tuple{T}, Tuple{T}} where T<:MolecularGraph.Graph.ModularProduct","page":"Clique","title":"MolecularGraph.Graph.maximumconnclique","text":"maximumconnclique(graph::ModularProduct; kwargs...\n    ) -> Tuple{Set{Int}, Symbol}\n\nReturn a maximum connected clique.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularGraph.jl-1","page":"Home","title":"MolecularGraph.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"README.md on GitHub","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Molecular graph modeling and chemoinformatics toolkit\nFully implemented in Julia\nMIT License","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":" (v1.0) pkg> add MolecularGraph","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Jupyter notebook tutorials","category":"page"}]
}
