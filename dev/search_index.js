var documenterSearchIndex = {"docs":
[{"location":"graph/traversal/#Graph-traversal","page":"Traversal","title":"Graph traversal","text":"","category":"section"},{"location":"graph/traversal/#Shortest-path","page":"Traversal","title":"Shortest path","text":"","category":"section"},{"location":"graph/traversal/","page":"Traversal","title":"Traversal","text":"Modules = [Graph]\nPages   = [\"graph/shortestpath.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/traversal/#MolecularGraph.Graph.diameter-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Traversal","title":"MolecularGraph.Graph.diameter","text":"diameter(graph::AbstractGraph) -> Int\n\nCompute the diameter of the graph (the largest eccentricity of any nodes).\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.distance-Tuple{Function,Any,Any,Any}","page":"Traversal","title":"MolecularGraph.Graph.distance","text":"distance(graph::AbstractGraph, source::Int, target::Int) -> Int\nreversedistance(graph::DirectedGraph, source::Int, target::Int) -> Int\n\nCompute the distance (shortest path length) from source to target. If the nodes are not reachable each other, the value will be nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.distancematrix-Tuple{Function,Any}","page":"Traversal","title":"MolecularGraph.Graph.distancematrix","text":"distancematrix(graph::OrderedGraph) -> Matrix{Float64}\n\nGenerate the distance matrix of the graph.\n\nNote that the type of the generated matrix will be Float64. If the nodes are not reachable each other, the distance value will be Inf.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.eccentricity-Tuple{Function,Any,Any}","page":"Traversal","title":"MolecularGraph.Graph.eccentricity","text":"eccentricity(graph::UndirectedGraph, v::Int) -> Int\n\nCompute the eccentricity of the graph (the largest distance between v and any other nodes).\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.isreachable-Tuple{MolecularGraph.Graph.UndirectedGraph,Int64,Int64}","page":"Traversal","title":"MolecularGraph.Graph.isreachable","text":"reachablenodes(graph::AbstractGraph, u::Int, v::Int) -> Bool\nreversereachablenodes(graph::DirectedGraph, u::Int, v::Int) -> Bool\n\nReturn whether the node v is reachable from u.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.longestshortestpathnodes-Tuple{MolecularGraph.Graph.UndirectedGraph}","page":"Traversal","title":"MolecularGraph.Graph.longestshortestpathnodes","text":"longestshortestpathnodes(graph::UndirectedGraph) -> Vector{Int}\n\nCompute the longest shortest path in the graph (a path between two arbitrary peripheral nodes) as a vector of nodes that starts with one of the peripheral node and ends with the other side.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.reachablenodes-Tuple{MolecularGraph.Graph.UndirectedGraph,Int64}","page":"Traversal","title":"MolecularGraph.Graph.reachablenodes","text":"reachablenodes(graph::AbstractGraph, node::Int) -> Set{Int}\nreversereachablenodes(graph::DirectedGraph, node::Int) -> Set{Int}\n\nReturn the set of reachable nodes from node.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.shortestpathedges-Tuple{Function,Any,Any,Any}","page":"Traversal","title":"MolecularGraph.Graph.shortestpathedges","text":"shortestpathedges(graph::UndirectedGraph, u::Int, v::Int) -> Vector{Int}\n\nCompute the shortest path between u and v as a vector of the edges that forms the path. Return nothing if not reachable.\n\n\n\n\n\n","category":"method"},{"location":"graph/traversal/#MolecularGraph.Graph.shortestpathnodes-Tuple{Function,Any,Any,Any}","page":"Traversal","title":"MolecularGraph.Graph.shortestpathnodes","text":"shortestpathnodes(graph::UndirectedGraph, u::Int, v::Int) -> Vector{Int}\n\nCompute the shortest path between u and v as a vector of the nodes that forms the path. Return nothing if not reachable.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#Graph-isomorphism","page":"Isomorphism","title":"Graph isomorphism","text":"","category":"section"},{"location":"graph/isomorphism/#Subgraph-match-(VF2-algorithm)","page":"Isomorphism","title":"Subgraph match (VF2 algorithm)","text":"","category":"section"},{"location":"graph/isomorphism/","page":"Isomorphism","title":"Isomorphism","text":"Modules = [Graph]\nPages   = [\"graph/isomorphism/vf2.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/isomorphism/#MolecularGraph.Graph.edgesubgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.edgesubgraphmatch","text":"edgesubgraphmatch(\n    G::AbstractGraph, H::AbstractGraph; kwargs...) -> Dict{Int,Int}\n\nReturn a edge induced subgraph isomorphism mapping between G and H. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.edgesubgraphmatches-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.edgesubgraphmatches","text":"edgesubgraphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Iterator\n\nGenerate edge induced subgraph isomorphism mappings between G and H. The returned iterator has ig => ih pairs that correspond to the indices of matching edges in G and H, respectively.\n\nSee MolecularGraph.edgesubgraph to construct the subgraphs that result from the match.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.graphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.graphmatch","text":"graphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Dict{Int,Int}\n\nReturn an isomorphism mapping between G and H. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.graphmatches-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.graphmatches","text":"graphmatches(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Iterator\n\nGenerate isomorphism mappings between G and H. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.isedgesubgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.isedgesubgraphmatch","text":"isedgesubgraphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Bool\n\nReturn true if a node induced subgraph of G and H are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.isgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.isgraphmatch","text":"isgraphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Bool\n\nReturn true if G and H are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.issubgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.issubgraphmatch","text":"issubgraphmatch(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Bool\n\nReturn true if a node induced subgraph of G and H are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.subgraphmatch-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.subgraphmatch","text":"subgraphmatch(\n    G::AbstractGraph, H::AbstractGraph; kwargs...) -> Dict{Int,Int}\n\nReturn a subgraph isomorphism mapping between G and H. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.subgraphmatches-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.subgraphmatches","text":"subgraphmatches(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Iterator\n\nGenerate subgraph isomorphism mappings between G and H.\n\nKeyword arguments\n\nnodematcher(Function): node matcher function that takes two node indices as\n\narguments.\n\nedgematcher(Function): edge matcher function that takes two edge indices as\n\narguments.\n\nmandatory(Dict{Int,Int}): mandatory node matches (available for only VF2)\nforbidden(Dict{Int,Int}):   forbidden node matches (available for only VF2)\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#Maximum-common-subgraph-(Clique-detection-based-algorithm)","page":"Isomorphism","title":"Maximum common subgraph (Clique detection based algorithm)","text":"","category":"section"},{"location":"graph/isomorphism/","page":"Isomorphism","title":"Isomorphism","text":"Modules = [Graph]\nPages   = [\"graph/isomorphism/cliquemcs.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/isomorphism/#MolecularGraph.Graph.findmces-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"Isomorphism","title":"MolecularGraph.Graph.findmces","text":"findmces(G::UndirectedGraph, H::UndirectedGraph; kwargs...\n    ) -> Tuple{Dict{Int,Int},Symbol}\n\nCompute maximum common edge induced subgraph between G and H.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.findmcis-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"Isomorphism","title":"MolecularGraph.Graph.findmcis","text":"findmcis(G::UndirectedGraph, H::UndirectedGraph; kwargs...\n    ) -> Tuple{Dict{Int,Int},Symbol}\n\nCompute maximum common induced subgraph between G and H.\n\nKeyword arguments:\n\nconnected(Bool): if true, apply connected MCS constraint.\ntopological(Bool): if true, apply topological constraint.\ndiameter(Int): distance cutoff for topological constraint.\ntolerance(Int): distance mismatch tolerance for topological constraint.\ntimeout(Int): abort calculation and return suboptimal results so far if the\n\nexecution time has reached the given value (default=60, in seconds).\n\ntargetsize(Int): abort calculation and return suboptimal result so far if the\n\ngiven mcs size achieved.\n\nnodematcher(Function): node matcher function that takes two node indices as\n\narguments.\n\nedgematcher(Function): edge matcher function that takes two edge indices as\n\narguments.\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.mcessize-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.mcessize","text":"mcessize(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Int\n\nReturn the maximum common edge induced subgraph size (number of edges).\n\n\n\n\n\n","category":"method"},{"location":"graph/isomorphism/#MolecularGraph.Graph.mcissize-Tuple{Any,Any}","page":"Isomorphism","title":"MolecularGraph.Graph.mcissize","text":"mcissize(G::AbstractGraph, H::AbstractGraph; kwargs...) -> Int\n\nReturn the maximum common induced subgraph size (number of nodes).\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#Graph-operations","page":"Operations","title":"Graph operations","text":"","category":"section"},{"location":"graph/operation/#Disjoint-union","page":"Operations","title":"Disjoint union","text":"","category":"section"},{"location":"graph/operation/","page":"Operations","title":"Operations","text":"Modules = [Graph]\nPages   = [\"graph/disjointunion.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/operation/#MolecularGraph.Graph.disjointunion!-Union{Tuple{T}, Tuple{T,T,Vararg{T,N} where N}} where T<:MolecularGraph.Graph.OrderedGraph","page":"Operations","title":"MolecularGraph.Graph.disjointunion!","text":"disjointunion!(g1::T, g2::T, G::T...) where {T<:OrderedGraph} -> T\n\nGenerate disjoint union graph of given graphs. g1 will be overwritten by the union graph. Unlike non-destructive disjointunion, g1 does not retain any information about other given graphs but a bit faster.\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#MolecularGraph.Graph.disjointunion-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph,Vararg{MolecularGraph.Graph.UndirectedGraph,N} where N}","page":"Operations","title":"MolecularGraph.Graph.disjointunion","text":"disjointunion(g1::UndirectedGraph, g2::UndirectedGraph,\n    G::UndirectedGraph...) -> DisjointUnionGraph\n\nGenerate disjoint union graph of given graphs. The new graph with type DisjointUnionGraph retains mapping to the original graphs as nodes and edges attributes.\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#Line-graph","page":"Operations","title":"Line graph","text":"","category":"section"},{"location":"graph/operation/","page":"Operations","title":"Operations","text":"Modules = [Graph]\nPages   = [\"graph/linegraph.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/operation/#MolecularGraph.Graph.linegraph-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Operations","title":"MolecularGraph.Graph.linegraph","text":"linegraph(G::AbstractGraph) -> LineGraph\n\nGenerate line graph.\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#Product-of-graphs","page":"Operations","title":"Product of graphs","text":"","category":"section"},{"location":"graph/operation/","page":"Operations","title":"Operations","text":"Modules = [Graph]\nPages   = [\"graph/product.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/operation/#MolecularGraph.Graph.cartesianproduct-Tuple{MolecularGraph.Graph.OrderedGraph,MolecularGraph.Graph.OrderedGraph}","page":"Operations","title":"MolecularGraph.Graph.cartesianproduct","text":"cartesianproduct(G::OrderedGraph, H::OrderedGraph) -> CartesianProduct\n\nReturn the cartesian product of graphs G and H.\n\n\n\n\n\n","category":"method"},{"location":"graph/operation/#MolecularGraph.Graph.modularproduct-Tuple{MolecularGraph.Graph.OrderedGraph,MolecularGraph.Graph.OrderedGraph}","page":"Operations","title":"MolecularGraph.Graph.modularproduct","text":"modularproduct(G::OrderedGraph, H::OrderedGraph) -> ModularProduct\n\nReturn the modular product of graphs G and H.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#Graph-generator","page":"Generator","title":"Graph generator","text":"","category":"section"},{"location":"graph/generator/","page":"Generator","title":"Generator","text":"Modules = [Graph]\nPages   = [\"graph/generator.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/generator/#MolecularGraph.Graph.circularladder-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.circularladder","text":"circularladder(n::Int; mutable=false) -> PlainGraph\n\nGenerate circular ladder graph CL_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.completebipartite-Tuple{Int64,Int64}","page":"Generator","title":"MolecularGraph.Graph.completebipartite","text":"completebipartite(m::Int,n::Int; mutable=false) -> PlainGraph\n\nGenerate bipartite graph K_mn.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.completegraph-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.completegraph","text":"completegraph(length::Int; mutable=false) -> PlainGraph\n\nGenerate complete graph K_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.cyclegraph-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.cyclegraph","text":"cyclegraph(length::Int; mutable=false) -> PlainGraph\n\nGenerate cycle graph C_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.generalizedpetersen-Tuple{Int64,Int64}","page":"Generator","title":"MolecularGraph.Graph.generalizedpetersen","text":"generalizedpetersen(n::Int, k::Int; mutable=false) -> PlainGraph\n\nGenerate generalized petersen graph G(nk).\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.laddergraph-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.laddergraph","text":"laddergraph(n::Int; mutable=false) -> PlainGraph\n\nGenerate ladder graph L_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.moebiusladder-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.moebiusladder","text":"moebiusladder(n::Int; mutable=false) -> PlainGraph\n\nGenerate Möbius ladder graph ML_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.pathgraph-Tuple{Int64}","page":"Generator","title":"MolecularGraph.Graph.pathgraph","text":"pathgraph(n::Int; mutable=false) -> PlainGraph\n\nGenerate path graph P_n.\n\n\n\n\n\n","category":"method"},{"location":"graph/generator/#MolecularGraph.Graph.squaregrid-Tuple{Int64,Int64}","page":"Generator","title":"MolecularGraph.Graph.squaregrid","text":"squaregrid(m::Int,n::Int; mutable=false) -> PlainGraph\n\nGenerate m times n square grid graph.\n\nUse cartesianproduct for higher dimensional grid graphs.\n\n\n\n\n\n","category":"method"},{"location":"geometry/cartesian/#Cartesian","page":"Cartesian","title":"Cartesian","text":"","category":"section"},{"location":"geometry/cartesian/","page":"Cartesian","title":"Cartesian","text":"Modules = [Geometry]\nPages   = [\"geometry/cartesian.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"geometry/cartesian/#MolecularGraph.Geometry.distance-Tuple{MolecularGraph.Geometry.Point,MolecularGraph.Geometry.Point}","page":"Cartesian","title":"MolecularGraph.Geometry.distance","text":"distance(u::Point, v::Point) -> Float64\ndistance(s::Segment) -> Float64\ndistance(coords::AbstractMatrix{T}) where {T<:Real} -> Float64\n\nReturn distance between two endpoints.\n\n\n\n\n\n","category":"method"},{"location":"geometry/cartesian/#MolecularGraph.Geometry.isclockwise-Tuple{AbstractArray{Float64,2}}","page":"Cartesian","title":"MolecularGraph.Geometry.isclockwise","text":"isclockwise(vertices::AbstractMatrix{Float64}) -> Union{Bool,Nothing}\n\nReturn true/false if given vertices of a polygon in 2D space are placed clockwise/anticlockwise. Return nothing if the polygon is self-intersecting or some vertices are overlapped.  \n\n\n\n\n\n","category":"method"},{"location":"geometry/cartesian/#MolecularGraph.Geometry.midpoint-Tuple{MolecularGraph.Geometry.Point,MolecularGraph.Geometry.Point}","page":"Cartesian","title":"MolecularGraph.Geometry.midpoint","text":"midpoint(u::Point, v::Point) -> Point\nmidpoint(s::Segment) -> Point\nmidpoint(coords::AbstractMatrix{T}) where {T<:Real} -> AbstractMatrix\n\nReturn the midpoint of u and v.\n\n\n\n\n\n","category":"method"},{"location":"geometry/cartesian/#MolecularGraph.Geometry.unitvector-Tuple{MolecularGraph.Geometry.Point,MolecularGraph.Geometry.Point}","page":"Cartesian","title":"MolecularGraph.Geometry.unitvector","text":"unitvector(u::Point, v::Point) -> Point\nunitvector(s::Segment) -> Point\nunitvector(coords::AbstractMatrix{T}) where {T<:Real} -> AbstractMatrix\n\nReturn u -> v vector of length 1.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"graph/interface/","page":"Interface","title":"Interface","text":"Modules = [Graph]\nPages   = [\"graph/interface.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/interface/#MolecularGraph.Graph.addnode!-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.AbstractNode}","page":"Interface","title":"MolecularGraph.Graph.addnode!","text":"addnode!(graph) -> Int\naddnode!(graph, attr) -> Int\n\nAdd new node and return the node index. If the node attribute type is required, specify the node attribute object by node keyword.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.clearcache!-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Interface","title":"MolecularGraph.Graph.clearcache!","text":"clearcache!(graph::AbstractGraph) -> nothing\n\nClear calculated property caches.\n\nCalling clearcache! is recommended when the graph nodes/edges are added, removed or reindexed. You can Graph.clone the graph before destructive operation instead.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.clone","page":"Interface","title":"MolecularGraph.Graph.clone","text":"clone(graph::AbstractGraph) -> AbstractGraph\n\nReturn deep copy of the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/interface/#MolecularGraph.Graph.edgeattr-Tuple{MolecularGraph.Graph.AbstractGraph,Int64,Int64}","page":"Interface","title":"MolecularGraph.Graph.edgeattr","text":"edgeattr(graph::AbstractGraph, u::Int, v::Int\n    ) -> Union{AbstractEdge,Nothing}\n\nReturn the attribute object of an edge that connects u and v. If not found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgeattr-Tuple{MolecularGraph.Graph.AbstractGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.edgeattr","text":"edgeattr(graph::AbstractGraph, i::Int) -> AbstractEdge\n\nReturn the attribute object of edge i.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgeattrs-Tuple{Union{MolecularGraph.Graph.OrderedDiGraph, MolecularGraph.Graph.OrderedGraph, MolecularGraph.Graph.OrderedHyperGraph}}","page":"Interface","title":"MolecularGraph.Graph.edgeattrs","text":"edgeattrs(graph::Union{OrderedGraph,OrderedDiGraph}) -> Vector{AbstractEdge}\n\nReturn graph edge attributes.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgeattrtype-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Interface","title":"MolecularGraph.Graph.edgeattrtype","text":"edgeattrtype(graph) -> Type\n\nReturn edge attribute type.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgecount-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Interface","title":"MolecularGraph.Graph.edgecount","text":"edgecount(graph::AbstractGraph) -> Int\n\nReturn the number of graph edges.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.edgeset-Tuple{Union{MolecularGraph.Graph.OrderedDiGraph, MolecularGraph.Graph.OrderedGraph, MolecularGraph.Graph.OrderedHyperGraph}}","page":"Interface","title":"MolecularGraph.Graph.edgeset","text":"edgeset(graph::Union{OrderedGraph,OrderedDiGraph}) -> Set{Int}\n\nReturn the set of edge keys.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.getedge-Tuple{MolecularGraph.Graph.AbstractGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.getedge","text":"getedge(graph::AbstractGraph, i::Int) -> Tuple{Int,Int}\ngetedge(graph::HyperGraph, i::Int) -> Set{Int}\n\nReturn an edge.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.hasedge-Tuple{MolecularGraph.Graph.AbstractGraph,Int64,Int64}","page":"Interface","title":"MolecularGraph.Graph.hasedge","text":"hasedge(graph::UndirectedGraph, u::Int, v::Int) -> Bool\nhasedge(graph::DirectedGraph, source::Int, target::Int) -> Bool\n\nReturn whether the given two nodes are connected by at least one edge.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.indegree-Tuple{MolecularGraph.Graph.DirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.indegree","text":"indegree(graph::DirectedGraph, n::Int) -> Int\n\nReturn the number of inneighbors of the node 'n'.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.inneighbors-Tuple{MolecularGraph.Graph.DirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.inneighbors","text":"inneighbors(graph::DirectedGraph, i::Int) -> Dict{Int,Int}\n\nReturn the mapping of predecessor node keys and in edge keys connected to the given node.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.neighborcount-Tuple{MolecularGraph.Graph.AbstractGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.neighborcount","text":"neighborcount(graph::AbstractGraph, n::Int) -> Int\ndegree(graph::AbstractGraph, n::Int) -> Int\n\nReturn the number of adjacent nodes of the node 'n'.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.neighbors-Tuple{MolecularGraph.Graph.UndirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.neighbors","text":"neighbors(graph, i) -> Dict{Int,Int}\n\nReturn the mapping of incident edges and adjacent nodes of node i. If the graph is directed graph, both outneighbors and inneighbors are mapped.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodeattr-Tuple{MolecularGraph.Graph.AbstractGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.nodeattr","text":"nodeattr(graph::AbstractGraph, i::Int) -> AbstractNode\n\nReturn the attribute object of node i.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodeattrs-Tuple{Union{MolecularGraph.Graph.OrderedDiGraph, MolecularGraph.Graph.OrderedGraph, MolecularGraph.Graph.OrderedHyperGraph}}","page":"Interface","title":"MolecularGraph.Graph.nodeattrs","text":"nodeattrs(graph::Union{OrderedGraph,OrderedDiGraph}) -> Vector{AbstractNode}\n\nReturn graph node attributes.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodeattrtype-Tuple{MolecularGraph.Graph.AbstractGraph}","page":"Interface","title":"MolecularGraph.Graph.nodeattrtype","text":"nodeattrtype(graph) -> Type\n\nReturn node attribute type.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodecount-Tuple{MolecularGraph.Graph.UndirectedGraph}","page":"Interface","title":"MolecularGraph.Graph.nodecount","text":"nodecount(graph::AbstractGraph) -> Int\n\nReturn the number of graph nodes.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.nodeset-Tuple{Union{MolecularGraph.Graph.OrderedDiGraph, MolecularGraph.Graph.OrderedGraph, MolecularGraph.Graph.OrderedHyperGraph}}","page":"Interface","title":"MolecularGraph.Graph.nodeset","text":"nodeset(graph::Union{OrderedGraph,OrderedDiGraph}) -> Set{Int}\n\nReturn the set of node keys.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.outdegree-Tuple{MolecularGraph.Graph.DirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.outdegree","text":"outdegree(graph::DirectedGraph, n::Int) -> Int\n\nReturn the number of outneighbors of the node 'n'.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.outneighbors-Tuple{MolecularGraph.Graph.DirectedGraph,Int64}","page":"Interface","title":"MolecularGraph.Graph.outneighbors","text":"outneighbors(graph::DirectedGraph, i::Int) -> Dict{Int,Int}\n\nReturn the mapping of successor node keys and out edge keys connected to the given node.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.setedgeattr!-Tuple{MolecularGraph.Graph.AbstractGraph,Int64,MolecularGraph.Graph.AbstractEdge}","page":"Interface","title":"MolecularGraph.Graph.setedgeattr!","text":"setedgeattr!(graph::AbstractGraph, i::Int, attr::AbstractNode)\n\nUpdate the edge attribute.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.setnodeattr!-Tuple{MolecularGraph.Graph.AbstractGraph,Int64,MolecularGraph.Graph.AbstractNode}","page":"Interface","title":"MolecularGraph.Graph.setnodeattr!","text":"setnodeattr!(graph::AbstractGraph, i::Int, attr::AbstractNode)\n\nUpdate the node attribute.\n\n\n\n\n\n","category":"method"},{"location":"graph/interface/#MolecularGraph.Graph.unlinkedges","page":"Interface","title":"MolecularGraph.Graph.unlinkedges","text":"unlinkedges(graph, edges)\n\nDelete given edges from the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/interface/#MolecularGraph.Graph.unlinknodes","page":"Interface","title":"MolecularGraph.Graph.unlinknodes","text":"unlinknodes(graph, nodes)\n\nDelete given nodes and its incident edges from the graph.\n\n\n\n\n\n","category":"function"},{"location":"moleculargraph/mcs/#Maximum-common-substructure","page":"MCS","title":"Maximum common substructure","text":"","category":"section"},{"location":"moleculargraph/mcs/","page":"MCS","title":"MCS","text":"Modules = [MolecularGraph]\nPages   = [\"mcs.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/mcs/#MolecularGraph.mcesmol-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"MCS","title":"MolecularGraph.mcesmol","text":"mcesmol(mol1::UndirectedGraph, mol2::UndirectedGraph; kwargs...\n    ) -> Tuple{Dict{Int,Int},Symbol}\n\nCompute maximum common edge induced substructure (MCES) of mol1 and mol2.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mcs/#MolecularGraph.mcismol-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"MCS","title":"MolecularGraph.mcismol","text":"mcismol(mol1::UndirectedGraph, mol2::UndirectedGraph; kwargs...\n    ) -> Tuple{Dict{Int,Int},Symbol}\n\nCompute maximum common induced substructure (MCIS) of mol1 and mol2.\n\nKeyword arguments\n\nconnected(Bool): if true, apply connected MCS constraint.\ntopological(Bool): if true, apply topological constraint.\ndiameter(Int): distance cutoff for topological constraint.\ntolerance(Int): distance mismatch tolerance for topological constraint.\ntimeout(Int): abort calculation and return suboptimal results if the execution\n\ntime has reached the given value (default=60, in seconds).\n\ntargetsize(Int): abort calculation and return suboptimal result so far if the\n\ngiven mcs size achieved.\n\nReferences\n\nKawabata, T. (2011). Build-Up Algorithm for Atomic Correspondence between\n\nChemical Structures. Journal of Chemical Information and Modeling, 51(8), 1775–1787. https://doi.org/10.1021/ci2001023\n\nhttps://www.jstage.jst.go.jp/article/ciqs/2017/0/2017P4/article/-char/en\n\n\n\n\n\n","category":"method"},{"location":"graph/topology/#Graph-topology","page":"Topology","title":"Graph topology","text":"","category":"section"},{"location":"graph/topology/#Cycle","page":"Topology","title":"Cycle","text":"","category":"section"},{"location":"graph/topology/","page":"Topology","title":"Topology","text":"Modules = [Graph]\nPages   = [\"graph/cycle.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/topology/#Connectivity","page":"Topology","title":"Connectivity","text":"","category":"section"},{"location":"graph/topology/","page":"Topology","title":"Topology","text":"Modules = [Graph]\nPages   = [\"graph/connectivity.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/topology/#Planarity","page":"Topology","title":"Planarity","text":"","category":"section"},{"location":"graph/topology/","page":"Topology","title":"Topology","text":"Modules = [Graph]\nPages   = [\"graph/planarity.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/topology/#MolecularGraph.Graph.isouterplanar-Tuple{MolecularGraph.Graph.UndirectedGraph}","page":"Topology","title":"MolecularGraph.Graph.isouterplanar","text":"isouterplanar(graph::UndirectedGraph) -> Bool\n\nReturn whether the graph is outerplanar. The outerplanarity test is based on a planarity test (see isplanar).\n\n\n\n\n\n","category":"method"},{"location":"graph/topology/#MolecularGraph.Graph.isplanar-Tuple{MolecularGraph.Graph.UndirectedGraph}","page":"Topology","title":"MolecularGraph.Graph.isplanar","text":"isplanar(graph::UndirectedGraph) -> Bool\n\nReturn whether the graph is planar.\n\nReference\n\nde Fraysseix, H., & Ossona de Mendez, P. (2012). Trémaux trees and planarity. European Journal of Combinatorics, 33(3), 279–293. https://doi.org/10.1016/j.ejc.2011.09.012\n\n\n\n\n\n","category":"method"},{"location":"graph/topology/#Triangles","page":"Topology","title":"Triangles","text":"","category":"section"},{"location":"graph/topology/","page":"Topology","title":"Topology","text":"Modules = [Graph]\nPages   = [\"graph/triangle.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/topology/#MolecularGraph.Graph.triangles-Tuple{MolecularGraph.Graph.UndirectedGraph}","page":"Topology","title":"MolecularGraph.Graph.triangles","text":"triangles(graph::UndirectedGraph) -> Set{Tuple{Int,Int,Int}}\n\nFast computation of finding triangle node sets in the graph.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/io/#Molecule-I/O","page":"I/O","title":"Molecule I/O","text":"","category":"section"},{"location":"moleculargraph/io/#SDFile-reader","page":"I/O","title":"SDFile reader","text":"","category":"section"},{"location":"moleculargraph/io/","page":"I/O","title":"I/O","text":"Modules = [MolecularGraph]\nPages   = [\"sdfilereader.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/io/#MolecularGraph.sdfilereader-Tuple{IO}","page":"I/O","title":"MolecularGraph.sdfilereader","text":"sdfilereader(file::IO)\nsdfilereader(path::AbstractString)\n\nRead SDFile data from input stream (or a file path as a string) and return a lazy iterator that yields molecule objects.\n\nsdfilereader does not stop and raise errors when an erroneous or incompatible SDFile block is read but produces an error message and yields an empty molecule. If this behavior is not desirable, you can use the customized supplier function instead of default supplier nohaltsupplier\n\nfunction customsupplier()\n    mol = try\n        parse(SDFile, block)\n    catch e\n        throw(ErrorException(\"incompatible molecule found, aborting...\"))\n    end\nend\n\nfunction sdfilereader(file::IO)\n    return SDFileReader(eachline(file), customsupplier)\nend\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/io/#MolecularGraph.sdftomol-Tuple{Any}","page":"I/O","title":"MolecularGraph.sdftomol","text":"sdftomol(lines) -> GraphMol{SDFileAtom,SDFileBond}\nsdftomol(file::IO) -> GraphMol{SDFileAtom,SDFileBond}\nsdftomol(path::AbstractString) -> GraphMol{SDFileAtom,SDFileBond}\n\nRead a SDFile(.sdf or .mol) and parse it into a molecule object. The given argument should be a file input stream, a file path as a string or an iterator that yields each sdfile text lines.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/io/#SDFile-writer","page":"I/O","title":"SDFile writer","text":"","category":"section"},{"location":"moleculargraph/io/","page":"I/O","title":"I/O","text":"Modules = [MolecularGraph]\nPages   = [\"sdfilewriter.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/io/#MolecularGraph.sdfilewriter-Tuple{IO,Any}","page":"I/O","title":"MolecularGraph.sdfilewriter","text":"sdfilewriter(io::IO, mols)\nsdfilewriter(filename::AbstractString, mols)\n\nWrite molecule data to the output stream as a SDFile format file.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/io/#SMILES/SMARTS","page":"I/O","title":"SMILES/SMARTS","text":"","category":"section"},{"location":"moleculargraph/io/","page":"I/O","title":"I/O","text":"Modules = [MolecularGraph]\nPages   = [\"smarts/base.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/io/#MolecularGraph.smartstomol-Tuple{AbstractString}","page":"I/O","title":"MolecularGraph.smartstomol","text":"smartstomol(smarts::AbstractString) -> QueryMol{SmartsAtom,SmartsBond}\n\nParse SMARTS string into QueryMol object.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/io/#MolecularGraph.smilestomol-Tuple{AbstractString}","page":"I/O","title":"MolecularGraph.smilestomol","text":"smilestomol(smiles::AbstractString) -> GraphMol{SmilesAtom,SmilesBond}\n\nParse SMILES string into GraphMol object.\n\n\n\n\n\n","category":"method"},{"location":"design/#Design-of-molecular-graph-models","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"","category":"section"},{"location":"design/#Graph-type-hierarchy","page":"Design of molecular graph models","title":"Graph type hierarchy","text":"","category":"section"},{"location":"design/","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"(AbstractGraph)\n(UndirectedGraph)\n(OrderedGraph)\nPlainGraph\nImmutablePlainGraph\nGraphMol{Atom,Bond}\nSDFile (Alias of GraphMol{SDFileAtom,SDFileBond})\nSMILES (Alias of GraphMol{SmilesAtom,SmilesBond})\nQueryMol{QueryAtom,QueryBond}\nSMARTS (Alias of QueryMol{SmartsAtom,SmartsBond})\nLineGraph\nCartesianProductGraph\nModularProductGraph\nSubgraphView{UndirectedGraph}\n(DirectedGraph)\n(OrderedDiGraph)\nPlainDiGraph\nFunctionalGroupClassGraph\nDiSubgraphView{DirectedGraph}\nHyperGraph?","category":"page"},{"location":"design/#AbstractGraph-methods","page":"Design of molecular graph models","title":"AbstractGraph methods","text":"","category":"section"},{"location":"design/","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"getnode, getedge, hasedge\nneighbors and its derivatives\nnodecount\nedgecount\nnodeset\nedgeset","category":"page"},{"location":"design/#DirectedGraph-methods","page":"Design of molecular graph models","title":"DirectedGraph methods","text":"","category":"section"},{"location":"design/","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"outneighbors and inneighbors","category":"page"},{"location":"design/#OrderedGraph-methods","page":"Design of molecular graph models","title":"OrderedGraph methods","text":"","category":"section"},{"location":"design/","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"nodesiter\nedgesiter\nnodeattrs\nedgeattrs","category":"page"},{"location":"design/#OrderedGraph","page":"Design of molecular graph models","title":"OrderedGraph","text":"","category":"section"},{"location":"design/","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"OrderedGraph consists of vectors of neighborhood map (incident edge => adjacent node) and edge (tuple of node index pair) vector.","category":"page"},{"location":"design/#QueryMol","page":"Design of molecular graph models","title":"QueryMol","text":"","category":"section"},{"location":"design/","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"QueryMol consists of QueryAtom and QueryBond that represent molecular query (ex. atom symbol is 'O' and charge is -1, bond order is 1 and not in rings, ...). This type of objects typically built from SMARTS query.","category":"page"},{"location":"design/#Node-type-hierarchy","page":"Design of molecular graph models","title":"Node type hierarchy","text":"","category":"section"},{"location":"design/","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"(AbstractNode)\n(Atom)\nSDFileAtom\nSmilesAtom\n(QueryAtom)\nSmartsAtom","category":"page"},{"location":"design/#Edge-type-hierarchy","page":"Design of molecular graph models","title":"Edge type hierarchy","text":"","category":"section"},{"location":"design/","page":"Design of molecular graph models","title":"Design of molecular graph models","text":"(AbstractEdge)\n(UndirectedEdge)\nEdge\n(Bond)\nSDFileBond\nSmilesBond\n(QueryBond)\nSmartsBond\n(DirectedEdge)\nArrow","category":"page"},{"location":"moleculargraph/properties/#Molecular-properties","page":"Chemical properties","title":"Molecular properties","text":"","category":"section"},{"location":"moleculargraph/properties/","page":"Chemical properties","title":"Chemical properties","text":"Modules = [MolecularGraph]\nPages   = [\"properties.jl\", \"wclogp.jl\", \"inchi.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/properties/#MolecularGraph.empiricalformula-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.empiricalformula","text":"empiricalformula(mol::GraphMol) -> String\n\nReturn the empirical formula in Hill system.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.hacceptorcount-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.hacceptorcount","text":"hacceptorcount(mol::GraphMol) -> Int\n\nReturn the number of hydrogen bond acceptors (N, O and F).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.hdonorcount-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.hdonorcount","text":"hdonorcount(mol::GraphMol) -> Int\n\nReturn the number of hydrogen bond donors (O and N attached to hydrogens).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.heavyatomcount-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.heavyatomcount","text":"heavyatomcount(mol::GraphMol) -> Int\n\nReturn the total number of non-hydrogen atoms.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.molecularformula-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.molecularformula","text":"molecularformula(mol::GraphMol) -> String\n\nReturn the molecular formula in Hill system.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.precalculate!-Tuple{Any}","page":"Chemical properties","title":"MolecularGraph.precalculate!","text":"precalculate!(mol::GraphMol)\n\nConvenient method to pre-calculate and cache performance bottleneck descriptors.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.rotatablecount-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.rotatablecount","text":"rotatablecount(mol::GraphMol) -> Int\n\nReturn the number of rotatable bonds.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.sssr","page":"Chemical properties","title":"MolecularGraph.sssr","text":"sssr(mol::UndirectedGraph) -> Vector{Vector{Int}}\n\nCalculate Small set of smallest rings (SSSR).\n\nThis returns a vector of rings represented as a vector of atom node index along with the cycle path.\n\n\n\n\n\n","category":"function"},{"location":"moleculargraph/properties/#MolecularGraph.sssrmembership","page":"Chemical properties","title":"MolecularGraph.sssrmembership","text":"sssrmembership(mol::UndirectedGraph) -> Vector{Set{Int}}\n\nReturn size n vector of SSSR membership set where n is the number of atom nodes.\n\nThe numbers in the set correspond to the index of sssr that the node belongs.\n\n\n\n\n\n","category":"function"},{"location":"moleculargraph/properties/#MolecularGraph.wclogp-Tuple{GraphMol}","page":"Chemical properties","title":"MolecularGraph.wclogp","text":"wclogp(mol::GraphMol) -> Float64\n\nReturn predicted logP value calculated by using Wildman and Crippen method.\n\nReference\n\nWildman, S. A. and Crippen, G. M. (1999). Prediction of Physicochemical Parameters by Atomic Contributions. Journal of Chemical Information and Modeling, 39(5), 868–873. https://doi.org/10.1021/ci990307l\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.inchi-Tuple{String}","page":"Chemical properties","title":"MolecularGraph.inchi","text":"inchi(molblock::String) -> String\ninchi(mol::GraphMol) -> String\n\nGenerate InChI string from molblock string or molecule\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/properties/#MolecularGraph.inchikey-Tuple{Union{Nothing, String}}","page":"Chemical properties","title":"MolecularGraph.inchikey","text":"inchikey(inchi::String) -> String\ninchikey(mol::GraphMol) -> String\n\nGenerate InChI key from InChI string or molecule\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#Preprocessing","page":"Preprocessing","title":"Preprocessing","text":"","category":"section"},{"location":"moleculargraph/preprocess/","page":"Preprocessing","title":"Preprocessing","text":"Modules = [MolecularGraph]\nPages   = [\"preprocess.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/preprocess/#MolecularGraph.addhydrogens-Union{Tuple{GraphMol{A,B}}, Tuple{B}, Tuple{A}} where B<:Bond where A<:Atom","page":"Preprocessing","title":"MolecularGraph.addhydrogens","text":"addhydrogens(mol::GraphMol) -> GraphMol\n\nReturn the molecule with all hydrogen nodes explicitly attached.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.allhydrogens-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.allhydrogens","text":"allhydrogens(mol::GraphMol) -> Set{Int}\n\nReturn a set of all hydrogen nodes.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.depolarize!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.depolarize!","text":"depolarize!(mol::GraphMol; negative=:O, positive=[:C, :P]) -> Nothing\n\nDepolarize dipole double bonds of the molecule.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.depolarize-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.depolarize","text":"depolarize(mol::GraphMol) -> GraphMol\n\nReturn the molecule with its dipole double bonds depolarized.\n\nSee depolarize!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.deprotonateoniums!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.deprotonateoniums!","text":"deprotonateoniums!(mol::GraphMol) -> Nothing\n\nDeprotonate onium groups of the molecule.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.deprotonateoniums-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.deprotonateoniums","text":"deprotonateoniums(mol::GraphMol) -> GraphMol\n\nReturn the molecule with its onium groups deprotonated.\n\nSee deprotonateoniums!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.extractlargestcomponent-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.extractlargestcomponent","text":"extractlargestcomponent(mol::GraphMol) -> GraphMol\n\nReturn the largest connected component of the molecular graph.\n\nThis should be useful when you want to remove salt and water molecules from the molecular graph simply. On the other hand, this can remove important components from the mixture so carefully apply this preprocess method.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.kekulize!-Tuple{GraphMol{SmilesAtom,SmilesBond}}","page":"Preprocessing","title":"MolecularGraph.kekulize!","text":"kekulize!(mol::SMILES) -> Nothing\n\nKekulize the molecule that has SMILES aromatic bonds.\n\nSMILES allows aromatic atoms in small letters - b, c, n, o, p, s, [as] and [se]. Once these are stored in SmilesAtom.isaromatic field, then kekulize will place double bonds to satisfy valences.\n\nKekulization is necessary for molecules parsed from SMILES. If not kekulized, some bond valence and implicit hydrogen properties would be wrong.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.kekulize-Tuple{GraphMol{SmilesAtom,SmilesBond}}","page":"Preprocessing","title":"MolecularGraph.kekulize","text":"kekulize(mol::SMILES) -> SMILES\n\nReturn the kekulized molecule. See kekulize!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.largestcomponentnodes-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.largestcomponentnodes","text":"largestcomponentnodes(mol::GraphMol) -> Set{Int}\n\nReturn a set of nodes in the largest connected component.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.polarize!","page":"Preprocessing","title":"MolecularGraph.polarize!","text":"polarize!(mol::GraphMol; negative=:O, positive=[:N, :S]) -> Nothing\n\nPolarize dipole double bonds of the molecule.\n\n\n\n\n\n","category":"function"},{"location":"moleculargraph/preprocess/#MolecularGraph.polarize-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.polarize","text":"polarize(mol::GraphMol) -> GraphMol\n\nReturn the molecule with its dipole double bonds polarized.\n\nSee polarize!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.protonateacids!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.protonateacids!","text":"protonateacids!(mol::GraphMol) -> GraphMol\n\nProtonate oxo(thio) anion groups of the molecule.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.protonateacids-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.protonateacids","text":"protonateacids(mol::GraphMol) -> GraphMol\n\nReturn the molecule with its oxo(thio) anion groups protonated.\n\nSee protonateacids!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.removehydrogens-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.removehydrogens","text":"removehydrogens(mol::GraphMol) -> GraphMol\n\nReturn the molecule with hydrogen nodes removed.\n\nIf option all is set to true (default), all hydrogens will be removed, otherwise only trivial hydrogens will be removed (see trivialhydrogens).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.toallenelike!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.toallenelike!","text":"toallenelike!(mol::GraphMol) -> Nothing\n\nStandardize the molecule so that all 1,3-dipole groups are represented as allene-like structure (e.g. Diazo group [C-][N+]#N -> C=[N+]=[N-]).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.toallenelike-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.toallenelike","text":"toallenelike(mol::GraphMol) -> GraphMol\n\nReturn the molecule standardized as the same way as toallenelike!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.totriplebond!-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.totriplebond!","text":"totriplebond!(mol::GraphMol) -> Nothing\n\nStandardize the molecule so that all 1,3-dipole groups are represented as triple bond and single bond (e.g. Diazo group C=[N+]=[N-] -> [C-][N+]#N).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.totriplebond-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.totriplebond","text":"totriplebond(mol::GraphMol) -> GraphMol\n\nReturn the molecule standardized as the same way as totriplebond!.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.trivialhydrogens-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.trivialhydrogens","text":"trivialhydrogens(mol::GraphMol) -> Set{Int}\n\nReturn a set of trivial hydrogen nodes.\n\n\"Trivial\" means not charged, no unpaired electron, no specific mass, non-stereospecific and attached to organic heavy atoms. Note that stereochemstry of SDFile molecules will not be considered until setstereocenter! is applied.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#Stereochemistry","page":"Preprocessing","title":"Stereochemistry","text":"","category":"section"},{"location":"moleculargraph/preprocess/","page":"Preprocessing","title":"Preprocessing","text":"Modules = [MolecularGraph]\nPages   = [\"stereo.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/preprocess/#MolecularGraph.addstereohydrogens-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.addstereohydrogens","text":"addstereohydrogens(mol::GraphMol) -> GraphMol\n\nAdd stereospecific hydrogen nodes to the molecule.\n\nIf the molecule was genereted from SDFile, run setstereocenter!(mol) in advance to set stereocenter information.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.optimizewedges!-Tuple{GraphMol{SDFileAtom,SDFileBond}}","page":"Preprocessing","title":"MolecularGraph.optimizewedges!","text":"optimizewedges!(mol::SDFile) -> Nothing\n\nOptimize dashes and wedges representations. Typical stereocenters can be drawn as four bonds including only a wedge and/or a dash, so if there are too many dashes and wedges, some of them will be converted to normal single bond without changing any stereochemistry.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.optimizewedges-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.optimizewedges","text":"optimizewedges(mol::GraphMol) -> GraphMol\n\nReturn new molecule with wedge configurations optimized.\n\nSee optimizewedges!)\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.removestereohydrogens-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.removestereohydrogens","text":"removestereohydrogens(mol::GraphMol) -> GraphMol\n\nReturn new molecule with stereospecific hydrogen nodes removed.\n\nIf the molecule was genereted from SDFile, run setstereocenter!(mol) in advance to set stereocenter information. This will keep stereochemistry of the molecule object. addstereohydrogens! can be used to revert the change. \n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.setdiastereo!-Tuple{GraphMol{SmilesAtom,SmilesBond}}","page":"Preprocessing","title":"MolecularGraph.setdiastereo!","text":"setdiastereo!(mol::Union{SMILES,SDFile}) -> Nothing\n\nSet diastereomerism flags to Bond.stereo fields of double bonds.\n\nBond.stereo::Symbol indicates whether the lower index nodes attached to each sides of the double bond is in :cis, :trans or :unspecified configuration. \n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.setdiastereo-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.setdiastereo","text":"setdiastereo(mol::GraphMol) -> GraphMol\n\nReturn new molecule with diastereomeric information set.\n\nSee setdiastereo!)\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.setstereocenter!-Tuple{GraphMol{SDFileAtom,SDFileBond}}","page":"Preprocessing","title":"MolecularGraph.setstereocenter!","text":"setstereocenter!(mol::SDFile) -> Nothing\n\nSet stereocenter information to Atom.stereo (:unspecified, :clockwise, :anticlockwise or :atypical). Clockwise/anticlockwise means the configuration of 2-4th nodes in index label order when we see the chiral center from the node labeled by the lowest index. If there is an implicit hydrogen, its index label will be regarded as the same as the stereocenter atom.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/preprocess/#MolecularGraph.setstereocenter-Tuple{GraphMol}","page":"Preprocessing","title":"MolecularGraph.setstereocenter","text":"setstereocenter(mol::GraphMol) -> GraphMol\n\nReturn new molecule with stereocenter information set.\n\nSee setstereocenter!)\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/funcgroup/#Functional-group-detection","page":"Functional group detection","title":"Functional group detection","text":"","category":"section"},{"location":"moleculargraph/funcgroup/","page":"Functional group detection","title":"Functional group detection","text":"Modules = [MolecularGraph]\nPages   = [\"funcgroup.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/funcgroup/#MolecularGraph.functionalgroupgraph-Tuple{GraphMol}","page":"Functional group detection","title":"MolecularGraph.functionalgroupgraph","text":"functionalgroupgraph(mol::GraphMol) -> FunctionalGroupClassifier\n\nGenerate functional group graph that is a directed acyclic graph similar to an ontology graph.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#Structure-match","page":"Substructure match","title":"Structure match","text":"","category":"section"},{"location":"moleculargraph/substructure/","page":"Substructure match","title":"Substructure match","text":"Modules = [MolecularGraph]\nPages   = [\"substructure.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/substructure/#MolecularGraph.fastquerymatches-Tuple{MolecularGraph.Graph.UndirectedGraph,QueryMol}","page":"Substructure match","title":"MolecularGraph.fastquerymatches","text":"fastquerymatches(mol::UndirectedGraph, query::QueryMol; kwargs...\n    ) -> Dict{Int,Int}\n\nGenerate query match mappings between mol and query. If no match found, return nothing.\n\nThe query should not have any component level expression that means it should not have any dots (.). This is intended for use in functional group detection.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#MolecularGraph.isquerymatch-Tuple{Any,Any}","page":"Substructure match","title":"MolecularGraph.isquerymatch","text":"isquerymatch(mol, query; kwargs...)\n\nReturn whether mol matches with the query.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#MolecularGraph.querymatch-Tuple{MolecularGraph.Graph.UndirectedGraph,QueryMol}","page":"Substructure match","title":"MolecularGraph.querymatch","text":"querymatch(mol::UndirectedGraph, query::QueryMol; kwargs...) -> Dict{Int,Int}\n\nGenerate substructure match mappings between mol1 and mol2. If no match found, return nothing.\n\nThis accepts also disconnected single atom but returns only the first match. This function is intended for use in SMARTS query search\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#MolecularGraph.structmatches-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"Substructure match","title":"MolecularGraph.structmatches","text":"structmatches(mol1::UndirectedGraph, mol2::UndirectedGraph; kwargs...) -> Iterator\n\nGenerate molecular graph match mappings between mol1 and mol2. If no match found, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/substructure/#MolecularGraph.substructmatches-Tuple{MolecularGraph.Graph.UndirectedGraph,MolecularGraph.Graph.UndirectedGraph}","page":"Substructure match","title":"MolecularGraph.substructmatches","text":"substructmatches(mol1::UndirectedGraph, mol2::UndirectedGraph; kwargs...) -> Iterator\n\nGenerate substructure match mappings between mol1 and mol2. If no match found, return nothing.\n\nThe mapping is based on only edge induced subgraph isomorphism and therefore it does not care disconnected single atom matches. This function is intended for use in substructure search. If you need single atom SMARTS match (ex. [#16;X2;!R]), see querymatch.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#Molecular-structure-drawing","page":"Structure drawing","title":"Molecular structure drawing","text":"","category":"section"},{"location":"moleculargraph/draw/","page":"Structure drawing","title":"Structure drawing","text":"Modules = [MolecularGraph]\nPages   = [\"./draw/base.jl\", \"./draw/draw2d.jl\", \"./draw/svg.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/draw/#MolecularGraph.DRAW_SETTING","page":"Structure drawing","title":"MolecularGraph.DRAW_SETTING","text":"DRAW_SETTING\n\nDefault setting parameters of the molecule drawing canvas.\n\nRequired fields\n\n:display_terminal_carbon(Bool) whether to display terminal C atom or not\n:double_bond_notation(Symbol)\n:alongside: all double bonds are represented as a carbon skeleton and               a segment alongside it.\n:dual: all double bonds are represented as two equal length parallel          segments.\n:chain: :dual for chain bonds and :alongside for ring bonds\n:terminal: :dual for terminal bonds (adjacent to degree=1 node) and              :alongside for others (default)\n:atomcolor(Dict{Symbol,Color}) atom symbol and bond colors for organic atoms\n:defaul_atom_color(Dict{Symbol,Color}) colors for other atoms\n\n\n\n\n\n","category":"constant"},{"location":"moleculargraph/draw/#MolecularGraph.chargesign-Tuple{Int64}","page":"Structure drawing","title":"MolecularGraph.chargesign","text":"chargesign(charge::Int) -> String\n\nGet a charge sign.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#MolecularGraph.draw2d!-Tuple{Canvas,MolecularGraph.Graph.UndirectedGraph}","page":"Structure drawing","title":"MolecularGraph.draw2d!","text":"draw2d!(canvas::Canvas, mol::UndirectedGraph; kwargs...)\n\nDraw molecular image to the canvas.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#MolecularGraph.drawsvg-Tuple{MolecularGraph.Graph.UndirectedGraph,Int64,Int64}","page":"Structure drawing","title":"MolecularGraph.drawsvg","text":"drawsvg(mol::GraphMol, width::Int, height::Int)\n\nGenerate molecular structure image as a SVG format string.\n\nwidth and height specifies the size of the image (width and height attribute of svg tag).\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/draw/#MolecularGraph.initcanvas!-Tuple{Canvas,AbstractArray{Float64,N} where N,Tuple}","page":"Structure drawing","title":"MolecularGraph.initcanvas!","text":"initcanvas!(canvas::Canvas, coords::AbstractArray{Float64}, boundary::Tuple)\n\nMove and adjust the size of the molecule for drawing.\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#Graph-model","page":"Graph models","title":"Graph model","text":"","category":"section"},{"location":"graph/model/#Plain-graph","page":"Graph models","title":"Plain graph","text":"","category":"section"},{"location":"graph/model/","page":"Graph models","title":"Graph models","text":"Modules = [Graph]\nPages   = [\"graph/plaingraph.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/model/#MolecularGraph.Graph.immutableplaingraph-Tuple{}","page":"Graph models","title":"MolecularGraph.Graph.immutableplaingraph","text":"immutableplaingraph() -> ImmutablePlainGraph\nimmutableplaingraph(size::Int, edges) -> ImmutablePlainGraph\nimmutableplaingraph(graph::UndirectedGraph) -> ImmutablePlainGraph\n\nConvert an arbitrary UndirectedGraph into a ImmutablePlainGraph.\n\nImmutablePlainGraph is same as PlainGraph except for availability of addnode! and addedge!, and no performance difference exists between these graphs. ImmutablePlainGraph is mainly used for unit testing to check adverse effect of some graph algorithm implementations.\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#MolecularGraph.Graph.plaingraph-Tuple{Int64,Any}","page":"Graph models","title":"MolecularGraph.Graph.plaingraph","text":"plaingraph(nodes, edges) -> PlainGraph{PlainNode,Edge}\n\nGenerate vector graph that have given nodes and edges represented by the list of node indices in integer and the list of pairs of node indices, respectively.\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#MolecularGraph.Graph.plaingraph-Tuple{MolecularGraph.Graph.OrderedGraph}","page":"Graph models","title":"MolecularGraph.Graph.plaingraph","text":"plaingraph(graph::OrderedGraph) -> PlainGraph\n\nConvert an arbitrary OrderedGraph into a PlainGraph.\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#MolecularGraph.Graph.plaingraph-Tuple{MolecularGraph.Graph.UndirectedGraph}","page":"Graph models","title":"MolecularGraph.Graph.plaingraph","text":"plaingraph(graph::UndirectedGraph) -> PlainGraph\n\nConvert an arbitrary UndirectedGraph into a PlainGraph.\n\nIf the given graph has non-sequential indices (ex. subgraph view), node and edge indices are sorted in ascending order and are re-indexed.\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#MolecularGraph.Graph.plaingraph-Tuple{}","page":"Graph models","title":"MolecularGraph.Graph.plaingraph","text":"plaingraph() -> PlainGraph\n\nGenerate empty PlainGraph.\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#Hyper-graph","page":"Graph models","title":"Hyper graph","text":"","category":"section"},{"location":"graph/model/","page":"Graph models","title":"Graph models","text":"Modules = [Graph]\nPages   = [\"graph/plainhypergraph.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/model/#MolecularGraph.Graph.plainhypergraph-Tuple{Int64,Any}","page":"Graph models","title":"MolecularGraph.Graph.plainhypergraph","text":"plainhypergraph(size, edges) -> PlainHyperGraph\n\nGenerate hyper graph that have given size (number of nodes) and edges (Sets of nodes).\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#MolecularGraph.Graph.plainhypergraph-Tuple{MolecularGraph.Graph.HyperGraph}","page":"Graph models","title":"MolecularGraph.Graph.plainhypergraph","text":"plainhypergraph(graph::HyperGraph) -> PlainHyperGraph\n\nConvert an arbitrary HyperGraph into a PlainHyperGraph.\n\nIf the given graph has non-sequential indices (ex. subgraph view), node and edge indices are sorted in ascending order and are re-indexed.\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#MolecularGraph.Graph.plainhypergraph-Tuple{MolecularGraph.Graph.OrderedHyperGraph}","page":"Graph models","title":"MolecularGraph.Graph.plainhypergraph","text":"plainhypergraph(graph::OrderedHyperGraph) -> PlainHyperGraph\n\nConvert an arbitrary OrderedHyperGraph into a PlainHyperGraph.\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#MolecularGraph.Graph.plainhypergraph-Tuple{}","page":"Graph models","title":"MolecularGraph.Graph.plainhypergraph","text":"plainhypergraph() -> PlainHyperGraph\n\nGenerate empty PlainGraph.\n\n\n\n\n\n","category":"method"},{"location":"graph/model/#Directed-Acyclic-Graph-(DAG)","page":"Graph models","title":"Directed Acyclic Graph (DAG)","text":"","category":"section"},{"location":"graph/model/","page":"Graph models","title":"Graph models","text":"Modules = [Graph]\nPages   = [\"graph/dag.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/model/#Bipartite-Graph","page":"Graph models","title":"Bipartite Graph","text":"","category":"section"},{"location":"graph/model/","page":"Graph models","title":"Graph models","text":"Modules = [Graph]\nPages   = [\"graph/bipartite.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/model/#MolecularGraph.Graph.twocoloring-Tuple{MolecularGraph.Graph.UndirectedGraph}","page":"Graph models","title":"MolecularGraph.Graph.twocoloring","text":"twocoloring(graph::UndirectedGraph)\n\nDo 2-coloring and return two sets of nodes.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/molecule/#Molecular-structure-drawing","page":"Molecule","title":"Molecular structure drawing","text":"","category":"section"},{"location":"moleculargraph/molecule/","page":"Molecule","title":"Molecule","text":"Modules = [MolecularGraph]\nPages   = [\"./model/interface.jl\", \"./model/atom.jl\", \"./model/bond.jl\", \"./model/molgraph.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/molecule/#MolecularGraph.atomnumber-Tuple{Symbol}","page":"Molecule","title":"MolecularGraph.atomnumber","text":"atomnumber(atomsymbol::Symbol) -> Int\natomnumber(atom::Atom) -> Int\n\nReturn atom number.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/molecule/#MolecularGraph.atomsymbol-Tuple{Int64}","page":"Molecule","title":"MolecularGraph.atomsymbol","text":"atomsymbol(n::Int) -> Symbol\n\nReturn atom symbol of given atomic number.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/molecule/#MolecularGraph.graphmol-Tuple{MolecularGraph.Graph.SubgraphView}","page":"Molecule","title":"MolecularGraph.graphmol","text":"graphmol(mol::SubgraphView{GraphMol}) -> GraphMol\n\nGenerate a new GraphMol from a substructure view.\n\nGraph property caches and attributes are not inherited.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/molecule/#MolecularGraph.graphmol-Union{Tuple{B}, Tuple{A}, Tuple{Any,Array{A,1},Array{B,1}}} where B<:Bond where A<:Atom","page":"Molecule","title":"MolecularGraph.graphmol","text":"graphmol(atoms::Vector{Atom}, bonds::Vector{Bond}) -> GraphMol\n\nGenerate GraphMol that has the given atom objects and edge objects.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/molecule/#MolecularGraph.graphmol-Union{Tuple{B}, Tuple{A}, Tuple{Type{A},Type{B}}} where B<:Bond where A<:Atom","page":"Molecule","title":"MolecularGraph.graphmol","text":"graphmol() -> GraphMol\n\nGenerate empty GraphMol.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/molecule/#MolecularGraph.graphmol-Union{Tuple{GraphMol{A,B}}, Tuple{B}, Tuple{A}} where B<:Bond where A<:Atom","page":"Molecule","title":"MolecularGraph.graphmol","text":"graphmol(mol::GraphMol; clearcache=true) -> GraphMol\n\nCopy GraphMol. Cached properties will be removed.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/molecule/#MolecularGraph.querymol-Union{Tuple{B}, Tuple{A}, Tuple{Any,Array{A,1},Array{B,1},Array{Array{Int64,1},1}}} where B<:QueryBond where A<:QueryAtom","page":"Molecule","title":"MolecularGraph.querymol","text":"querymol(atoms::Vector{Atom}, bonds::Vector{Bond}) -> GraphMol\n\nGenerate QueryMol that has the given atom objects and edge objects.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/molecule/#MolecularGraph.querymol-Union{Tuple{B}, Tuple{A}, Tuple{Type{A},Type{B}}} where B<:QueryBond where A<:QueryAtom","page":"Molecule","title":"MolecularGraph.querymol","text":"querymol() -> QueryMol\n\nGenerate empty QueryMol.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/molecule/#MolecularGraph.todict-Tuple{GraphMol}","page":"Molecule","title":"MolecularGraph.todict","text":"todict(graph::GraphMol) -> Dict{String,Any}\n\nConvert molecule object into JSON compatible dictionary.\n\n\n\n\n\n","category":"method"},{"location":"graph/clique/#Maximum-clique","page":"Clique","title":"Maximum clique","text":"","category":"section"},{"location":"graph/clique/","page":"Clique","title":"Clique","text":"Modules = [Graph]\nPages   = [\"graph/clique.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"graph/clique/#MolecularGraph.Graph.maximalcliques-Tuple{T} where T<:MolecularGraph.Graph.UndirectedGraph","page":"Clique","title":"MolecularGraph.Graph.maximalcliques","text":"maximalcliques(graph::UndirectedGraph; kwargs...\n    ) -> Tuple{Vector{Set{Int}}, Symbol}\n\nReturn maximal cliques.\n\nReference\n\nTomita, E., Tanaka, A., & Takahashi, H. (2006). The worst-case time complexity for generating all maximal cliques and computational experiments. Theoretical Computer Science, 363(1), 28–42. https://doi.org/10.1016/J.TCS.2006.06.015\nCazals, F., & Karande, C. (2008). A note on the problem of reporting maximal cliques. Theoretical Computer Science, 407(1–3), 564–568. https://doi.org/10.1016/j.tcs.2008.05.010\n\n\n\n\n\n","category":"method"},{"location":"graph/clique/#MolecularGraph.Graph.maximalconncliques-Tuple{T} where T<:MolecularGraph.Graph.UndirectedGraph","page":"Clique","title":"MolecularGraph.Graph.maximalconncliques","text":"maximalconncliques(graph::ModularProduct; kwargs...\n    ) -> Tuple{Vector{Set{Int}}, Symbol}\n\nReturn maximal connected cliques.\n\nReference\n\nCazals, F., & Karande, C. (2005). An algorithm for reporting maximal c-cliques. Theoretical Computer Science, 349(3), 484–490. https://doi.org/10.1016/j.tcs.2005.09.038\n\n\n\n\n\n","category":"method"},{"location":"graph/clique/#MolecularGraph.Graph.maximumclique-Tuple{T} where T<:MolecularGraph.Graph.UndirectedGraph","page":"Clique","title":"MolecularGraph.Graph.maximumclique","text":"maximumclique(graph::UndirectedGraph; kwargs...) -> Tuple{Set{Int}, Symbol}\n\nReturn a maximum clique.\n\n\n\n\n\n","category":"method"},{"location":"graph/clique/#MolecularGraph.Graph.maximumconnclique-Tuple{T} where T<:MolecularGraph.Graph.ModularProduct","page":"Clique","title":"MolecularGraph.Graph.maximumconnclique","text":"maximumconnclique(graph::ModularProduct; kwargs...\n    ) -> Tuple{Set{Int}, Symbol}\n\nReturn a maximum connected clique.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#Molecular-mass/weight","page":"Molecular mass/weight","title":"Molecular mass/weight","text":"","category":"section"},{"location":"moleculargraph/mass/","page":"Molecular mass/weight","title":"Molecular mass/weight","text":"Modules = [MolecularGraph]\nPages   = [\"mass.jl\"]\nPrivate = false\nOrder   = [:constant, :function, :type]","category":"page"},{"location":"moleculargraph/mass/#MolecularGraph.exactmass-Tuple{Symbol}","page":"Molecular mass/weight","title":"MolecularGraph.exactmass","text":"exactmass(atomsymbol::Symbol) -> Tuple{Float64,Float64}\nexactmass(atomsymbol::Symbol, number::Int) -> Tuple{Float64,Float64}\nexactmass(atom::Atom) -> Tuple{Float64,Float64}\nexactmass(mol::GraphMol) -> Tuple{Float64,Float64}\n\nReturn a tuple of calculated exact mass and its uncertainty.\n\nIf number is not given or Atom.mass is not specified, monoisotopic mass will be used instead.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#MolecularGraph.exactmass-Tuple{Type{Float64},Symbol}","page":"Molecular mass/weight","title":"MolecularGraph.exactmass","text":"exactmass(::Type{Float64}, atomsymbol::Symbol) -> Float64\nexactmass(::Type{Float64}, atomsymbol::Symbol, number::Int) -> Float64\nexactmass(::Type{Float64}, atom::Atom) -> Float64\nexactmass(::Type{Float64}, mol::GraphMol) -> Float64\n\nReturn calculated exact mass rounded to digit=6.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#MolecularGraph.isotopiccomposition-Tuple{Symbol,Int64}","page":"Molecular mass/weight","title":"MolecularGraph.isotopiccomposition","text":"isotopiccomposition(atomsymbol::Symbol, number::Int; threshold=0.001\n    ) -> Vector{Tuple{Float64,Float64}}\nisotopiccomposition(mol::GraphMol; threshold=0.001\n    ) -> Vector{Tuple{Float64,Float64}}\n\nReturn isotopic composition of the atoms/molecule as a vector of tuples of mass and composition.\n\nRecords that have lower abundance than the given threshold will be filtered out (default 0.001 = 0.1%)\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#MolecularGraph.massspecpeaks-Tuple{GraphMol}","page":"Molecular mass/weight","title":"MolecularGraph.massspecpeaks","text":"massspecpeaks(mol::GraphMol; threshold=0.001) -> Matrix{Float64}\n\nReturn a vector of tuples of each isotopic masses and their relative intensity in the simulated mass spectrum (base peak intensity = 100).\n\nRecords that have lower abundance (not peak intensity) than the given threshold will be filtered out (default 0.001 = 0.1%)\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#MolecularGraph.monoisotopicmass-Tuple{Symbol}","page":"Molecular mass/weight","title":"MolecularGraph.monoisotopicmass","text":"monoisotopicmass(atomsymbol::Symbol) -> Tuple{Float64,Float64}\nmonoisotopicmass(atom::Atom) -> Tuple{Float64,Float64}\nmonoisotopicmass(mol::GraphMol) -> Tuple{Float64,Float64}\n\nReturn a tuple of monoisotopic mass of the atom/molecule and its uncertainty.\n\nMonoisotopic mass is the relative atomic mass of the most abundant isotope. Even if there is specific Atom.mass value, it will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#MolecularGraph.monoisotopicmass-Tuple{Type{Float64},Symbol}","page":"Molecular mass/weight","title":"MolecularGraph.monoisotopicmass","text":"monoisotopicmass(::Type{Float64}, atomsymbol::Symbol) -> Float64\nmonoisotopicmass(::Type{Float64}, atom::Atom) -> Float64\nmonoisotopicmass(::Type{Float64}, mol::GraphMol) -> Float64\n\nReturn monoisotopic mass of the atom/molecule rounded to digits=6.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#MolecularGraph.monoisotopicmass-Union{Tuple{T}, Tuple{Type{T},Symbol}} where T<:Integer","page":"Molecular mass/weight","title":"MolecularGraph.monoisotopicmass","text":"monoisotopicmass(::Type{T}, atomsymbol::Symbol) where {T<:Integer} -> T\nmonoisotopicmass(::Type{T}, atom::Atom) where {T<:Integer} -> T\nmonoisotopicmass(::Type{T}, mol::GraphMol) where {T<:Integer} -> T\nnominalmass(atomsymbol::Symbol) -> Int\nnominalmass(atom::Atom) -> Int\nnominalmass(mol::GraphMol) -> Int\n\nReturn nominal mass of the atom/molecule.\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#MolecularGraph.simulatemassspec-Tuple{Array{Tuple{Float64,Float64},1}}","page":"Molecular mass/weight","title":"MolecularGraph.simulatemassspec","text":"simulatemassspec(peaks::Vector{Tuple{Float64,Float64}};\n    resolution=10000, rate=0.01) -> Matrix{Float64}\nsimulatemassspec(mol::GraphMol;\n    threshold=0.001, resolution=10000, rate=0.01) -> Matrix{Float64}\n\nReturn a matrix of simulate mass spectrum (dim 1: datapoints, dim 2: mass and intensity).\n\nUsage (with Plot.jl)\n\nusing MolecularGraph\nusing Plots\ngr()\nPlots.GRBackend()\n\nmol = smilestomol(\"CCO\")\ndata = simulatemassspec(mol)\nplot(\n    data[:, 1], data[:, 2],\n    leg=false, xlabel = \"Mass\", ylabel = \"Intensity\"\n)\n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#MolecularGraph.standardweight-Tuple{Symbol}","page":"Molecular mass/weight","title":"MolecularGraph.standardweight","text":"standardweight(atomsymbol::Symbol) -> Tuple{Float64,Float64}\nstandardweight(atom::Atom) -> Tuple{Float64,Float64}\nstandardweight(mol::GraphMol) -> Tuple{Float64,Float64}\n\nReturn a tuple of standard atomic weight (or molecular weight) and its uncertainty.\n\nIf Atom.mass is specified, calculated exact mass of the atom will be used instead. \n\n\n\n\n\n","category":"method"},{"location":"moleculargraph/mass/#MolecularGraph.standardweight-Tuple{Type{Float64},Symbol}","page":"Molecular mass/weight","title":"MolecularGraph.standardweight","text":"standardweight(::Type{Float64}, atomsymbol::Symbol) -> Float64\nstandardweight(::Type{Float64}, atom::Atom) -> Float64\nstandardweight(::Type{Float64}, mol::GraphMol) -> Float64\n\nReturn standard atomic weight (or molecular weight) rounded to digit=2.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularGraph.jl","page":"Home","title":"MolecularGraph.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"README.md on GitHub","category":"page"},{"location":"","page":"Home","title":"Home","text":"Molecular graph modeling and chemoinformatics toolkit\nFully implemented in Julia\nMIT License","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(@v1.4) pkg> add MolecularGraph","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Jupyter notebook tutorials","category":"page"}]
}
